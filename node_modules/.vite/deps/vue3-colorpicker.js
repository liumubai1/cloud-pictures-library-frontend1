import {
  isVue2
} from "./chunk-HYZ2CRGS.js";
import {
  merge_default
} from "./chunk-JRMO56US.js";
import {
  Fragment,
  Teleport,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  inject,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onScopeDispose,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  unref,
  useSlots,
  vModelText,
  vShow,
  watch,
  withCtx,
  withDirectives
} from "./chunk-U3LI7FBV.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/gradient-parser/build/node.js
var require_node = __commonJS({
  "node_modules/gradient-parser/build/node.js"(exports) {
    var GradientParser = GradientParser || {};
    GradientParser.stringify = /* @__PURE__ */ function() {
      var visitor = {
        "visit_linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_gradient": function(node) {
          var orientation = visitor.visit(node.orientation);
          if (orientation) {
            orientation += ", ";
          }
          return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
        },
        "visit_shape": function(node) {
          var result = node.value, at3 = visitor.visit(node.at), style = visitor.visit(node.style);
          if (style) {
            result += " " + style;
          }
          if (at3) {
            result += " at " + at3;
          }
          return result;
        },
        "visit_default-radial": function(node) {
          var result = "", at3 = visitor.visit(node.at);
          if (at3) {
            result += at3;
          }
          return result;
        },
        "visit_extent-keyword": function(node) {
          var result = node.value, at3 = visitor.visit(node.at);
          if (at3) {
            result += " at " + at3;
          }
          return result;
        },
        "visit_position-keyword": function(node) {
          return node.value;
        },
        "visit_position": function(node) {
          return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
        },
        "visit_%": function(node) {
          return node.value + "%";
        },
        "visit_em": function(node) {
          return node.value + "em";
        },
        "visit_px": function(node) {
          return node.value + "px";
        },
        "visit_literal": function(node) {
          return visitor.visit_color(node.value, node);
        },
        "visit_hex": function(node) {
          return visitor.visit_color("#" + node.value, node);
        },
        "visit_rgb": function(node) {
          return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
        },
        "visit_rgba": function(node) {
          return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
        },
        "visit_color": function(resultColor, node) {
          var result = resultColor, length = visitor.visit(node.length);
          if (length) {
            result += " " + length;
          }
          return result;
        },
        "visit_angular": function(node) {
          return node.value + "deg";
        },
        "visit_directional": function(node) {
          return "to " + node.value;
        },
        "visit_array": function(elements) {
          var result = "", size = elements.length;
          elements.forEach(function(element, i3) {
            result += visitor.visit(element);
            if (i3 < size - 1) {
              result += ", ";
            }
          });
          return result;
        },
        "visit": function(element) {
          if (!element) {
            return "";
          }
          var result = "";
          if (element instanceof Array) {
            return visitor.visit_array(element, result);
          } else if (element.type) {
            var nodeVisitor = visitor["visit_" + element.type];
            if (nodeVisitor) {
              return nodeVisitor(element);
            } else {
              throw Error("Missing visitor visit_" + element.type);
            }
          } else {
            throw Error("Invalid node.");
          }
        }
      };
      return function(root) {
        return visitor.visit(root);
      };
    }();
    var GradientParser = GradientParser || {};
    GradientParser.parse = /* @__PURE__ */ function() {
      var tokens = {
        linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
        repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
        radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
        repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /^\#([0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^rgb/i,
        rgbaColor: /^rgba/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
      };
      var input = "";
      function error(msg) {
        var err = new Error(input + ": " + msg);
        err.source = input;
        throw err;
      }
      function getAST() {
        var ast = matchListDefinitions();
        if (input.length > 0) {
          error("Invalid input not EOF");
        }
        return ast;
      }
      function matchListDefinitions() {
        return matchListing(matchDefinition);
      }
      function matchDefinition() {
        return matchGradient(
          "linear-gradient",
          tokens.linearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "repeating-linear-gradient",
          tokens.repeatingLinearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "radial-gradient",
          tokens.radialGradient,
          matchListRadialOrientations
        ) || matchGradient(
          "repeating-radial-gradient",
          tokens.repeatingRadialGradient,
          matchListRadialOrientations
        );
      }
      function matchGradient(gradientType, pattern, orientationMatcher) {
        return matchCall(pattern, function(captures) {
          var orientation = orientationMatcher();
          if (orientation) {
            if (!scan(tokens.comma)) {
              error("Missing comma before color stops");
            }
          }
          return {
            type: gradientType,
            orientation,
            colorStops: matchListing(matchColorStop)
          };
        });
      }
      function matchCall(pattern, callback) {
        var captures = scan(pattern);
        if (captures) {
          if (!scan(tokens.startCall)) {
            error("Missing (");
          }
          var result = callback(captures);
          if (!scan(tokens.endCall)) {
            error("Missing )");
          }
          return result;
        }
      }
      function matchLinearOrientation() {
        return matchSideOrCorner() || matchAngle();
      }
      function matchSideOrCorner() {
        return match("directional", tokens.sideOrCorner, 1);
      }
      function matchAngle() {
        return match("angular", tokens.angleValue, 1);
      }
      function matchListRadialOrientations() {
        var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
        if (radialOrientation) {
          radialOrientations = [];
          radialOrientations.push(radialOrientation);
          lookaheadCache = input;
          if (scan(tokens.comma)) {
            radialOrientation = matchRadialOrientation();
            if (radialOrientation) {
              radialOrientations.push(radialOrientation);
            } else {
              input = lookaheadCache;
            }
          }
        }
        return radialOrientations;
      }
      function matchRadialOrientation() {
        var radialType = matchCircle() || matchEllipse();
        if (radialType) {
          radialType.at = matchAtPosition();
        } else {
          var extent = matchExtentKeyword();
          if (extent) {
            radialType = extent;
            var positionAt = matchAtPosition();
            if (positionAt) {
              radialType.at = positionAt;
            }
          } else {
            var defaultPosition = matchPositioning();
            if (defaultPosition) {
              radialType = {
                type: "default-radial",
                at: defaultPosition
              };
            }
          }
        }
        return radialType;
      }
      function matchCircle() {
        var circle = match("shape", /^(circle)/i, 0);
        if (circle) {
          circle.style = matchLength() || matchExtentKeyword();
        }
        return circle;
      }
      function matchEllipse() {
        var ellipse = match("shape", /^(ellipse)/i, 0);
        if (ellipse) {
          ellipse.style = matchDistance() || matchExtentKeyword();
        }
        return ellipse;
      }
      function matchExtentKeyword() {
        return match("extent-keyword", tokens.extentKeywords, 1);
      }
      function matchAtPosition() {
        if (match("position", /^at/, 0)) {
          var positioning = matchPositioning();
          if (!positioning) {
            error("Missing positioning value");
          }
          return positioning;
        }
      }
      function matchPositioning() {
        var location = matchCoordinates();
        if (location.x || location.y) {
          return {
            type: "position",
            value: location
          };
        }
      }
      function matchCoordinates() {
        return {
          x: matchDistance(),
          y: matchDistance()
        };
      }
      function matchListing(matcher) {
        var captures = matcher(), result = [];
        if (captures) {
          result.push(captures);
          while (scan(tokens.comma)) {
            captures = matcher();
            if (captures) {
              result.push(captures);
            } else {
              error("One extra comma");
            }
          }
        }
        return result;
      }
      function matchColorStop() {
        var color = matchColor();
        if (!color) {
          error("Expected color definition");
        }
        color.length = matchDistance();
        return color;
      }
      function matchColor() {
        return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
      }
      function matchLiteralColor() {
        return match("literal", tokens.literalColor, 0);
      }
      function matchHexColor() {
        return match("hex", tokens.hexColor, 1);
      }
      function matchRGBColor() {
        return matchCall(tokens.rgbColor, function() {
          return {
            type: "rgb",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchRGBAColor() {
        return matchCall(tokens.rgbaColor, function() {
          return {
            type: "rgba",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchNumber() {
        return scan(tokens.number)[1];
      }
      function matchDistance() {
        return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
      }
      function matchPositionKeyword() {
        return match("position-keyword", tokens.positionKeywords, 1);
      }
      function matchLength() {
        return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
      }
      function match(type, pattern, captureIndex) {
        var captures = scan(pattern);
        if (captures) {
          return {
            type,
            value: captures[captureIndex]
          };
        }
      }
      function scan(regexp) {
        var captures, blankCaptures;
        blankCaptures = /^[\n\r\t\s]+/.exec(input);
        if (blankCaptures) {
          consume(blankCaptures[0].length);
        }
        captures = regexp.exec(input);
        if (captures) {
          consume(captures[0].length);
        }
        return captures;
      }
      function consume(size) {
        input = input.substr(size);
      }
      return function(code) {
        input = code.toString();
        return getAST();
      };
    }();
    exports.parse = GradientParser.parse;
    exports.stringify = GradientParser.stringify;
  }
});

// node_modules/@vueuse/shared/index.mjs
function tryOnScopeDispose(fn3) {
  if (getCurrentScope()) {
    onScopeDispose(fn3);
    return true;
  }
  return false;
}
function toValue(r3) {
  return typeof r3 === "function" ? r3() : unref(r3);
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn3) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn3.apply(this, args), { fn: fn3, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const filter = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function cacheStringFunction(fn3) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn3(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_3, c3) => c3 ? c3.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn3) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn3();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function useDebounceFn(fn3, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn3
  );
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function tryOnMounted(fn3, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn3, target);
  else if (sync)
    fn3();
  else
    nextTick(fn3);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start2(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop);
  return {
    isPending: readonly(isPending),
    start: start2,
    stop
  };
}
function whenever(source, cb, options) {
  const stop = watch(
    source,
    (v3, ov, onInvalidate) => {
      if (v3) {
        if (options == null ? void 0 : options.once)
          nextTick(() => stop());
        cb(v3, ov, onInvalidate);
      }
    },
    {
      ...options,
      once: false
    }
  );
  return stop;
}

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn3) => fn3());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
var _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
  if (!window2)
    return noop;
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
    window2.document.documentElement.addEventListener("click", noop);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  const listener = (event) => {
    const el = unrefElement(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e2) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e2) && !!(el && !e2.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler(event);
        }
      }, 0);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn3) => fn3());
  return stop;
}
function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, isVue2 ? void 0 : instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function usePermission(permissionDesc, options = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options;
  const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = ref();
  const onChange = () => {
    if (permissionStatus)
      state.value = permissionStatus.state;
  };
  const query = createSingletonPromise(async () => {
    if (!isSupported.value)
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator2.permissions.query(desc);
        useEventListener(permissionStatus, "change", onChange);
        onChange();
      } catch (e2) {
        state.value = "prompt";
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}
function useClipboard(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read: read2 = false,
    source,
    copiedDuring = 1500,
    legacy = false
  } = options;
  const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const permissionRead = usePermission("clipboard-read");
  const permissionWrite = usePermission("clipboard-write");
  const isSupported = computed(() => isClipboardApiSupported.value || legacy);
  const text = ref("");
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateText() {
    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
      navigator2.clipboard.readText().then((value) => {
        text.value = value;
      });
    } else {
      text.value = legacyRead();
    }
  }
  if (isSupported.value && read2)
    useEventListener(["copy", "cut"], updateText);
  async function copy(value = toValue(source)) {
    if (isSupported.value && value != null) {
      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))
        await navigator2.clipboard.writeText(value);
      else
        legacyCopy(value);
      text.value = value;
      copied.value = true;
      timeout.start();
    }
  }
  function legacyCopy(value) {
    const ta = document.createElement("textarea");
    ta.value = value != null ? value : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacyRead() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  function isAllowed(status) {
    return status === "granted" || status === "prompt";
  }
  return {
    isSupported,
    text,
    copied,
    copy
  };
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var StorageSerializers = {
  boolean: {
    read: (v3) => v3 === "true",
    write: (v3) => String(v3)
  },
  object: {
    read: (v3) => JSON.parse(v3),
    write: (v3) => JSON.stringify(v3)
  },
  number: {
    read: (v3) => Number.parseFloat(v3),
    write: (v3) => String(v3)
  },
  any: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  string: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  map: {
    read: (v3) => new Map(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3.entries()))
  },
  set: {
    read: (v3) => new Set(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3))
  },
  date: {
    read: (v3) => new Date(v3),
    write: (v3) => v3.toISOString()
  }
};
var customStorageEventName = "vueuse-storage";
function useStorage(key, defaults, storage, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    },
    initOnMounted
  } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults === "function" ? defaults() : defaults);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e2) {
      onError(e2);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data,
    () => write2(data.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      useEventListener(window2, "storage", update);
      useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update();
    });
  }
  if (!initOnMounted)
    update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      window2.dispatchEvent(new CustomEvent(customStorageEventName, {
        detail: {
          key,
          oldValue,
          newValue,
          storageArea: storage
        }
      }));
    }
  }
  function write2(v3) {
    try {
      const oldValue = storage.getItem(key);
      if (v3 == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v3);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e2) {
      onError(e2);
    }
  }
  function read2(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read2(event);
    } catch (e2) {
      onError(e2);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R3, G2, B3;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R3 = RsRGB / 12.92;
    else R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G2 = GsRGB / 12.92;
    else G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B3 = BsRGB / 12.92;
    else B3 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R3 + 0.7152 * G2 + 0.0722 * B3;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h4 = Math.round(hsv.h * 360), s3 = Math.round(hsv.s * 100), v3 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h4 + ", " + s3 + "%, " + v3 + "%)" : "hsva(" + h4 + ", " + s3 + "%, " + v3 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h4 = Math.round(hsl.h * 360), s3 = Math.round(hsl.s * 100), l3 = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h4 + ", " + s3 + "%, " + l3 + "%)" : "hsla(" + h4 + ", " + s3 + "%, " + l3 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s3 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s3._r, s3._g, s3._b, s3._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString2(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn3, args) {
    var color = fn3.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn3, args) {
    return fn3.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i3 in color) {
      if (color.hasOwnProperty(i3)) {
        if (i3 === "a") {
          newColor[i3] = color[i3];
        } else {
          newColor[i3] = convertToPercentage(color[i3]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s3 = null;
  var v3 = null;
  var l3 = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s3 = convertToPercentage(color.s);
      v3 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s3, v3);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s3 = convertToPercentage(color.s);
      l3 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s3, l3);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a3 = color.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a3
  };
}
function rgbToRgb(r3, g3, b3) {
  return {
    r: bound01(r3, 255) * 255,
    g: bound01(g3, 255) * 255,
    b: bound01(b3, 255) * 255
  };
}
function rgbToHsl(r3, g3, b3) {
  r3 = bound01(r3, 255);
  g3 = bound01(g3, 255);
  b3 = bound01(b3, 255);
  var max2 = Math.max(r3, g3, b3), min2 = Math.min(r3, g3, b3);
  var h4, s3, l3 = (max2 + min2) / 2;
  if (max2 == min2) {
    h4 = s3 = 0;
  } else {
    var d3 = max2 - min2;
    s3 = l3 > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
    switch (max2) {
      case r3:
        h4 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
        break;
      case g3:
        h4 = (b3 - r3) / d3 + 2;
        break;
      case b3:
        h4 = (r3 - g3) / d3 + 4;
        break;
    }
    h4 /= 6;
  }
  return {
    h: h4,
    s: s3,
    l: l3
  };
}
function hslToRgb(h4, s3, l3) {
  var r3, g3, b3;
  h4 = bound01(h4, 360);
  s3 = bound01(s3, 100);
  l3 = bound01(l3, 100);
  function hue2rgb(p4, q4, t3) {
    if (t3 < 0) t3 += 1;
    if (t3 > 1) t3 -= 1;
    if (t3 < 1 / 6) return p4 + (q4 - p4) * 6 * t3;
    if (t3 < 1 / 2) return q4;
    if (t3 < 2 / 3) return p4 + (q4 - p4) * (2 / 3 - t3) * 6;
    return p4;
  }
  if (s3 === 0) {
    r3 = g3 = b3 = l3;
  } else {
    var q3 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
    var p3 = 2 * l3 - q3;
    r3 = hue2rgb(p3, q3, h4 + 1 / 3);
    g3 = hue2rgb(p3, q3, h4);
    b3 = hue2rgb(p3, q3, h4 - 1 / 3);
  }
  return {
    r: r3 * 255,
    g: g3 * 255,
    b: b3 * 255
  };
}
function rgbToHsv(r3, g3, b3) {
  r3 = bound01(r3, 255);
  g3 = bound01(g3, 255);
  b3 = bound01(b3, 255);
  var max2 = Math.max(r3, g3, b3), min2 = Math.min(r3, g3, b3);
  var h4, s3, v3 = max2;
  var d3 = max2 - min2;
  s3 = max2 === 0 ? 0 : d3 / max2;
  if (max2 == min2) {
    h4 = 0;
  } else {
    switch (max2) {
      case r3:
        h4 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
        break;
      case g3:
        h4 = (b3 - r3) / d3 + 2;
        break;
      case b3:
        h4 = (r3 - g3) / d3 + 4;
        break;
    }
    h4 /= 6;
  }
  return {
    h: h4,
    s: s3,
    v: v3
  };
}
function hsvToRgb(h4, s3, v3) {
  h4 = bound01(h4, 360) * 6;
  s3 = bound01(s3, 100);
  v3 = bound01(v3, 100);
  var i3 = Math.floor(h4), f3 = h4 - i3, p3 = v3 * (1 - s3), q3 = v3 * (1 - f3 * s3), t3 = v3 * (1 - (1 - f3) * s3), mod = i3 % 6, r3 = [v3, q3, p3, p3, t3, v3][mod], g3 = [t3, v3, v3, q3, p3, p3][mod], b3 = [p3, p3, t3, v3, v3, q3][mod];
  return {
    r: r3 * 255,
    g: g3 * 255,
    b: b3 * 255
  };
}
function rgbToHex(r3, g3, b3, allow3Char) {
  var hex = [pad2(Math.round(r3).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b3).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r3, g3, b3, a3, allow4Char) {
  var hex = [pad2(Math.round(r3).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b3).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r3, g3, b3, a3) {
  var hex = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r3).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b3).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i3 = 1; i3 < number; i3++) {
    result.push(tinycolor({
      h: (hsl.h + i3 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h4 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h4 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h4 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h4 = hsv.h, s3 = hsv.s, v3 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h4,
      s: s3,
      v: v3
    }));
    v3 = (v3 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p3 = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p3 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p3 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p3 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p3 + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i3 = 0; i3 < colorList.length; i3++) {
    readability = tinycolor.readability(baseColor, colorList[i3]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i3]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o3) {
  var flipped = {};
  for (var i3 in o3) {
    if (o3.hasOwnProperty(i3)) {
      flipped[o3[i3]] = i3;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n3, max2) {
  if (isOnePointZero(n3)) n3 = "100%";
  var processPercent = isPercentage(n3);
  n3 = Math.min(max2, Math.max(0, parseFloat(n3)));
  if (processPercent) {
    n3 = parseInt(n3 * max2, 10) / 100;
  }
  if (Math.abs(n3 - max2) < 1e-6) {
    return 1;
  }
  return n3 % max2 / parseFloat(max2);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n3) {
  return typeof n3 == "string" && n3.indexOf(".") != -1 && parseFloat(n3) === 1;
}
function isPercentage(n3) {
  return typeof n3 === "string" && n3.indexOf("%") != -1;
}
function pad2(c3) {
  return c3.length == 1 ? "0" + c3 : "" + c3;
}
function convertToPercentage(n3) {
  if (n3 <= 1) {
    n3 = n3 * 100 + "%";
  }
  return n3;
}
function convertDecimalToHex(d3) {
  return Math.round(parseFloat(d3) * 255).toString(16);
}
function convertHexToDecimal(h4) {
  return parseIntFromHex(h4) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// node_modules/vue3-colorpicker/index.es.js
var import_gradient_parser = __toESM(require_node());

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x3 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x3 + width,
    bottom: y3 + height,
    left: x3,
    x: x3,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v3 = within(min2, value, max2);
  return v3 > max2 ? max2 : v3;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x3 = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x3 * dpr) / dpr || 0,
    y: round(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x3,
    y: y3
  }) : {
    x: x3,
    y: y3
  };
  x3 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x3 -= offsetX - popperRect.width;
      x3 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x3,
    y: y3
  }, getWindow(popper2)) : {
    x: x3,
    y: y3
  };
  x3 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y3 + "px)" : "translate3d(" + x3 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x3 = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3 + getWindowScrollBarX(element),
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x3 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b3) {
    return overflows[a3] - overflows[b3];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x3 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x3;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/vue3-colorpicker/node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject2(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function isPlainObject(o3) {
  var ctor, prot;
  if (isObject2(o3) === false) return false;
  ctor = o3.constructor;
  if (ctor === void 0) return true;
  prot = ctor.prototype;
  if (isObject2(prot) === false) return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/vue3-colorpicker/node_modules/vue-types/dist/vue-types.modern.js
function t() {
  return t = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r3 = arguments[t3];
      for (var n3 in r3) Object.prototype.hasOwnProperty.call(r3, n3) && (e2[n3] = r3[n3]);
    }
    return e2;
  }, t.apply(this, arguments);
}
function r(e2, t3) {
  if (null == e2) return {};
  var r3, n3, i3 = {}, o3 = Object.keys(e2);
  for (n3 = 0; n3 < o3.length; n3++) t3.indexOf(r3 = o3[n3]) >= 0 || (i3[r3] = e2[r3]);
  return i3;
}
var n = { silent: false, logLevel: "warn" };
var i = ["validator"];
var o = Object.prototype;
var a = o.toString;
var s = o.hasOwnProperty;
var u = /^\s*function (\w+)/;
function l(e2) {
  var t3;
  const r3 = null !== (t3 = null == e2 ? void 0 : e2.type) && void 0 !== t3 ? t3 : e2;
  if (r3) {
    const e3 = r3.toString().match(u);
    return e3 ? e3[1] : "";
  }
  return "";
}
var c = isPlainObject;
var f = (e2) => e2;
var d = f;
if (true) {
  const e2 = "undefined" != typeof console;
  d = e2 ? function(e3, t3 = n.logLevel) {
    false === n.silent && console[t3](`[VueTypes warn]: ${e3}`);
  } : f;
}
var p = (e2, t3) => s.call(e2, t3);
var y = Number.isInteger || function(e2) {
  return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
};
var v = Array.isArray || function(e2) {
  return "[object Array]" === a.call(e2);
};
var h2 = (e2) => "[object Function]" === a.call(e2);
var b = (e2) => c(e2) && p(e2, "_vueTypes_name");
var g = (e2) => c(e2) && (p(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t3) => p(e2, t3)));
function O(e2, t3) {
  return Object.defineProperty(e2.bind(t3), "__original", { value: e2 });
}
function m(e2, t3, r3 = false) {
  let n3, i3 = true, o3 = "";
  n3 = c(e2) ? e2 : { type: e2 };
  const a3 = b(n3) ? n3._vueTypes_name + " - " : "";
  if (g(n3) && null !== n3.type) {
    if (void 0 === n3.type || true === n3.type) return i3;
    if (!n3.required && void 0 === t3) return i3;
    v(n3.type) ? (i3 = n3.type.some((e3) => true === m(e3, t3, true)), o3 = n3.type.map((e3) => l(e3)).join(" or ")) : (o3 = l(n3), i3 = "Array" === o3 ? v(t3) : "Object" === o3 ? c(t3) : "String" === o3 || "Number" === o3 || "Boolean" === o3 || "Function" === o3 ? function(e3) {
      if (null == e3) return "";
      const t4 = e3.constructor.toString().match(u);
      return t4 ? t4[1] : "";
    }(t3) === o3 : t3 instanceof n3.type);
  }
  if (!i3) {
    const e3 = `${a3}value "${t3}" should be of type "${o3}"`;
    return false === r3 ? (d(e3), false) : e3;
  }
  if (p(n3, "validator") && h2(n3.validator)) {
    const e3 = d, o4 = [];
    if (d = (e4) => {
      o4.push(e4);
    }, i3 = n3.validator(t3), d = e3, !i3) {
      const e4 = (o4.length > 1 ? "* " : "") + o4.join("\n* ");
      return o4.length = 0, false === r3 ? (d(e4), i3) : e4;
    }
  }
  return i3;
}
function j(e2, t3) {
  const r3 = Object.defineProperties(t3, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
    return this.required = true, this;
  } }, def: { value(e3) {
    return void 0 === e3 ? (p(this, "default") && delete this.default, this) : h2(e3) || true === m(this, e3, true) ? (this.default = v(e3) ? () => [...e3] : c(e3) ? () => Object.assign({}, e3) : e3, this) : (d(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
  } } }), { validator: n3 } = r3;
  return h2(n3) && (r3.validator = O(n3, r3)), r3;
}
function _(e2, t3) {
  const r3 = j(e2, t3);
  return Object.defineProperty(r3, "validate", { value(e3) {
    return h2(this.validator) && d(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O(e3, this), this;
  } });
}
function T(e2, t3, n3) {
  const o3 = function(e3) {
    const t4 = {};
    return Object.getOwnPropertyNames(e3).forEach((r3) => {
      t4[r3] = Object.getOwnPropertyDescriptor(e3, r3);
    }), Object.defineProperties({}, t4);
  }(t3);
  if (o3._vueTypes_name = e2, !c(n3)) return o3;
  const { validator: a3 } = n3, s3 = r(n3, i);
  if (h2(a3)) {
    let { validator: e3 } = o3;
    e3 && (e3 = null !== (l3 = (u3 = e3).__original) && void 0 !== l3 ? l3 : u3), o3.validator = O(e3 ? function(t4) {
      return e3.call(this, t4) && a3.call(this, t4);
    } : a3, o3);
  }
  var u3, l3;
  return Object.assign(o3, s3);
}
function $(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
var w = () => _("any", {});
var P = () => _("function", { type: Function });
var x = () => _("boolean", { type: Boolean });
var E = () => _("string", { type: String });
var N = () => _("number", { type: Number });
var q = () => _("array", { type: Array });
var A = () => _("object", { type: Object });
var V = () => j("integer", { type: Number, validator: (e2) => y(e2) });
var S = () => j("symbol", { validator: (e2) => "symbol" == typeof e2 });
function D(e2, t3 = "custom validation failed") {
  if ("function" != typeof e2) throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return j(e2.name || "<<anonymous function>>", { type: null, validator(r3) {
    const n3 = e2(r3);
    return n3 || d(`${this._vueTypes_name} - ${t3}`), n3;
  } });
}
function L(e2) {
  if (!v(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const t3 = `oneOf - value should be one of "${e2.join('", "')}".`, r3 = e2.reduce((e3, t4) => {
    if (null != t4) {
      const r4 = t4.constructor;
      -1 === e3.indexOf(r4) && e3.push(r4);
    }
    return e3;
  }, []);
  return j("oneOf", { type: r3.length > 0 ? r3 : void 0, validator(r4) {
    const n3 = -1 !== e2.indexOf(r4);
    return n3 || d(t3), n3;
  } });
}
function F(e2) {
  if (!v(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let t3 = false, r3 = [];
  for (let n4 = 0; n4 < e2.length; n4 += 1) {
    const i3 = e2[n4];
    if (g(i3)) {
      if (b(i3) && "oneOf" === i3._vueTypes_name && i3.type) {
        r3 = r3.concat(i3.type);
        continue;
      }
      if (h2(i3.validator) && (t3 = true), true === i3.type || !i3.type) {
        d('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      r3 = r3.concat(i3.type);
    } else r3.push(i3);
  }
  r3 = r3.filter((e3, t4) => r3.indexOf(e3) === t4);
  const n3 = r3.length > 0 ? r3 : null;
  return j("oneOfType", t3 ? { type: n3, validator(t4) {
    const r4 = [], n4 = e2.some((e3) => {
      const n5 = m(b(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t4, true);
      return "string" == typeof n5 && r4.push(n5), true === n5;
    });
    return n4 || d(`oneOfType - provided value does not match any of the ${r4.length} passed-in validators:
${$(r4.join("\n"))}`), n4;
  } } : { type: n3 });
}
function Y(e2) {
  return j("arrayOf", { type: Array, validator(t3) {
    let r3 = "";
    const n3 = t3.every((t4) => (r3 = m(e2, t4, true), true === r3));
    return n3 || d(`arrayOf - value validation error:
${$(r3)}`), n3;
  } });
}
function B(e2) {
  return j("instanceOf", { type: e2 });
}
function I(e2) {
  return j("objectOf", { type: Object, validator(t3) {
    let r3 = "";
    const n3 = Object.keys(t3).every((n4) => (r3 = m(e2, t3[n4], true), true === r3));
    return n3 || d(`objectOf - value validation error:
${$(r3)}`), n3;
  } });
}
function J(e2) {
  const t3 = Object.keys(e2), r3 = t3.filter((t4) => {
    var r4;
    return !(null === (r4 = e2[t4]) || void 0 === r4 || !r4.required);
  }), n3 = j("shape", { type: Object, validator(n4) {
    if (!c(n4)) return false;
    const i3 = Object.keys(n4);
    if (r3.length > 0 && r3.some((e3) => -1 === i3.indexOf(e3))) {
      const e3 = r3.filter((e4) => -1 === i3.indexOf(e4));
      return d(1 === e3.length ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
    }
    return i3.every((r4) => {
      if (-1 === t3.indexOf(r4)) return true === this._vueTypes_isLoose || (d(`shape - shape definition does not include a "${r4}" property. Allowed keys: "${t3.join('", "')}".`), false);
      const i4 = m(e2[r4], n4[r4], true);
      return "string" == typeof i4 && d(`shape - "${r4}" property validation error:
 ${$(i4)}`), true === i4;
    });
  } });
  return Object.defineProperty(n3, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n3, "loose", { get() {
    return this._vueTypes_isLoose = true, this;
  } }), n3;
}
var M = ["name", "validate", "getter"];
var R = (() => {
  var e2;
  return (e2 = class {
    static get any() {
      return w();
    }
    static get func() {
      return P().def(this.defaults.func);
    }
    static get bool() {
      return x().def(this.defaults.bool);
    }
    static get string() {
      return E().def(this.defaults.string);
    }
    static get number() {
      return N().def(this.defaults.number);
    }
    static get array() {
      return q().def(this.defaults.array);
    }
    static get object() {
      return A().def(this.defaults.object);
    }
    static get integer() {
      return V().def(this.defaults.integer);
    }
    static get symbol() {
      return S();
    }
    static get nullable() {
      return { type: null };
    }
    static extend(e3) {
      if (v(e3)) return e3.forEach((e4) => this.extend(e4)), this;
      const { name: t3, validate: n3 = false, getter: i3 = false } = e3, o3 = r(e3, M);
      if (p(this, t3)) throw new TypeError(`[VueTypes error]: Type "${t3}" already defined`);
      const { type: a3 } = o3;
      if (b(a3)) return delete o3.type, Object.defineProperty(this, t3, i3 ? { get: () => T(t3, a3, o3) } : { value(...e4) {
        const r3 = T(t3, a3, o3);
        return r3.validator && (r3.validator = r3.validator.bind(r3, ...e4)), r3;
      } });
      let s3;
      return s3 = i3 ? { get() {
        const e4 = Object.assign({}, o3);
        return n3 ? _(t3, e4) : j(t3, e4);
      }, enumerable: true } : { value(...e4) {
        const r3 = Object.assign({}, o3);
        let i4;
        return i4 = n3 ? _(t3, r3) : j(t3, r3), r3.validator && (i4.validator = r3.validator.bind(i4, ...e4)), i4;
      }, enumerable: true }, Object.defineProperty(this, t3, s3);
    }
  }).defaults = {}, e2.sensibleDefaults = void 0, e2.config = n, e2.custom = D, e2.oneOf = L, e2.instanceOf = B, e2.oneOfType = F, e2.arrayOf = Y, e2.objectOf = I, e2.shape = J, e2.utils = { validate: (e3, t3) => true === m(t3, e3, true), toType: (e3, t3, r3 = false) => r3 ? _(e3, t3) : j(e3, t3) }, e2;
})();
function z(e2 = { func: () => {
}, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var r3;
  return (r3 = class extends R {
    static get sensibleDefaults() {
      return t({}, this.defaults);
    }
    static set sensibleDefaults(r4) {
      this.defaults = false !== r4 ? t({}, true !== r4 ? r4 : e2) : {};
    }
  }).defaults = t({}, e2), r3;
}
var C = class extends z() {
};

// node_modules/@aesoper/normal-utils/NormalUtils.es.js
var t2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function e(t3) {
  var e2 = { exports: {} };
  return t3(e2, e2.exports), e2.exports;
}
var n2 = function(t3) {
  return t3 && t3.Math == Math && t3;
};
var r2 = n2("object" == typeof globalThis && globalThis) || n2("object" == typeof window && window) || n2("object" == typeof self && self) || n2("object" == typeof t2 && t2) || /* @__PURE__ */ function() {
  return this;
}() || Function("return this")();
var o2 = function(t3) {
  try {
    return !!t3();
  } catch (t4) {
    return true;
  }
};
var i2 = !o2(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
});
var u2 = {}.propertyIsEnumerable;
var a2 = Object.getOwnPropertyDescriptor;
var c2 = { f: a2 && !u2.call({ 1: 2 }, 1) ? function(t3) {
  var e2 = a2(this, t3);
  return !!e2 && e2.enumerable;
} : u2 };
var l2 = function(t3, e2) {
  return { enumerable: !(1 & t3), configurable: !(2 & t3), writable: !(4 & t3), value: e2 };
};
var f2 = {}.toString;
var s2 = function(t3) {
  return f2.call(t3).slice(8, -1);
};
var d2 = "".split;
var v2 = o2(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(t3) {
  return "String" == s2(t3) ? d2.call(t3, "") : Object(t3);
} : Object;
var p2 = function(t3) {
  if (null == t3) throw TypeError("Can't call method on " + t3);
  return t3;
};
var g2 = function(t3) {
  return v2(p2(t3));
};
var h3 = function(t3) {
  return "object" == typeof t3 ? null !== t3 : "function" == typeof t3;
};
var y2 = function(t3, e2) {
  if (!h3(t3)) return t3;
  var n3, r3;
  if (e2 && "function" == typeof (n3 = t3.toString) && !h3(r3 = n3.call(t3))) return r3;
  if ("function" == typeof (n3 = t3.valueOf) && !h3(r3 = n3.call(t3))) return r3;
  if (!e2 && "function" == typeof (n3 = t3.toString) && !h3(r3 = n3.call(t3))) return r3;
  throw TypeError("Can't convert object to primitive value");
};
var m2 = {}.hasOwnProperty;
var S2 = function(t3, e2) {
  return m2.call(t3, e2);
};
var x2 = r2.document;
var b2 = h3(x2) && h3(x2.createElement);
var E2 = function(t3) {
  return b2 ? x2.createElement(t3) : {};
};
var w2 = !i2 && !o2(function() {
  return 7 != Object.defineProperty(E2("div"), "a", { get: function() {
    return 7;
  } }).a;
});
var O2 = Object.getOwnPropertyDescriptor;
var T2 = { f: i2 ? O2 : function(t3, e2) {
  if (t3 = g2(t3), e2 = y2(e2, true), w2) try {
    return O2(t3, e2);
  } catch (t4) {
  }
  if (S2(t3, e2)) return l2(!c2.f.call(t3, e2), t3[e2]);
} };
var A2 = function(t3) {
  if (!h3(t3)) throw TypeError(String(t3) + " is not an object");
  return t3;
};
var k = Object.defineProperty;
var R2 = { f: i2 ? k : function(t3, e2, n3) {
  if (A2(t3), e2 = y2(e2, true), A2(n3), w2) try {
    return k(t3, e2, n3);
  } catch (t4) {
  }
  if ("get" in n3 || "set" in n3) throw TypeError("Accessors not supported");
  return "value" in n3 && (t3[e2] = n3.value), t3;
} };
var I2 = i2 ? function(t3, e2, n3) {
  return R2.f(t3, e2, l2(1, n3));
} : function(t3, e2, n3) {
  return t3[e2] = n3, t3;
};
var j2 = function(t3, e2) {
  try {
    I2(r2, t3, e2);
  } catch (n3) {
    r2[t3] = e2;
  }
  return e2;
};
var C2 = r2["__core-js_shared__"] || j2("__core-js_shared__", {});
var L2 = Function.toString;
"function" != typeof C2.inspectSource && (C2.inspectSource = function(t3) {
  return L2.call(t3);
});
var P2;
var M2;
var _2;
var D2 = C2.inspectSource;
var U = r2.WeakMap;
var N2 = "function" == typeof U && /native code/.test(D2(U));
var F2 = e(function(t3) {
  (t3.exports = function(t4, e2) {
    return C2[t4] || (C2[t4] = void 0 !== e2 ? e2 : {});
  })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "© 2021 Denis Pushkarev (zloirock.ru)" });
});
var W = 0;
var z2 = Math.random();
var $2 = function(t3) {
  return "Symbol(" + String(void 0 === t3 ? "" : t3) + ")_" + (++W + z2).toString(36);
};
var B2 = F2("keys");
var Y2 = function(t3) {
  return B2[t3] || (B2[t3] = $2(t3));
};
var G = {};
var H = r2.WeakMap;
if (N2) {
  X = C2.state || (C2.state = new H()), V2 = X.get, K = X.has, q3 = X.set;
  P2 = function(t3, e2) {
    return e2.facade = t3, q3.call(X, t3, e2), e2;
  }, M2 = function(t3) {
    return V2.call(X, t3) || {};
  }, _2 = function(t3) {
    return K.call(X, t3);
  };
} else {
  Q = Y2("state");
  G[Q] = true, P2 = function(t3, e2) {
    return e2.facade = t3, I2(t3, Q, e2), e2;
  }, M2 = function(t3) {
    return S2(t3, Q) ? t3[Q] : {};
  }, _2 = function(t3) {
    return S2(t3, Q);
  };
}
var X;
var V2;
var K;
var q3;
var Q;
var J2 = { set: P2, get: M2, has: _2, enforce: function(t3) {
  return _2(t3) ? M2(t3) : P2(t3, {});
}, getterFor: function(t3) {
  return function(e2) {
    var n3;
    if (!h3(e2) || (n3 = M2(e2)).type !== t3) throw TypeError("Incompatible receiver, " + t3 + " required");
    return n3;
  };
} };
var Z = e(function(t3) {
  var e2 = J2.get, n3 = J2.enforce, o3 = String(String).split("String");
  (t3.exports = function(t4, e3, i3, u3) {
    var a3, c3 = !!u3 && !!u3.unsafe, l3 = !!u3 && !!u3.enumerable, f3 = !!u3 && !!u3.noTargetGet;
    "function" == typeof i3 && ("string" != typeof e3 || S2(i3, "name") || I2(i3, "name", e3), (a3 = n3(i3)).source || (a3.source = o3.join("string" == typeof e3 ? e3 : ""))), t4 !== r2 ? (c3 ? !f3 && t4[e3] && (l3 = true) : delete t4[e3], l3 ? t4[e3] = i3 : I2(t4, e3, i3)) : l3 ? t4[e3] = i3 : j2(e3, i3);
  })(Function.prototype, "toString", function() {
    return "function" == typeof this && e2(this).source || D2(this);
  });
});
var tt = r2;
var et = function(t3) {
  return "function" == typeof t3 ? t3 : void 0;
};
var nt = function(t3, e2) {
  return arguments.length < 2 ? et(tt[t3]) || et(r2[t3]) : tt[t3] && tt[t3][e2] || r2[t3] && r2[t3][e2];
};
var rt = Math.ceil;
var ot = Math.floor;
var it = function(t3) {
  return isNaN(t3 = +t3) ? 0 : (t3 > 0 ? ot : rt)(t3);
};
var ut = Math.min;
var at = function(t3) {
  return t3 > 0 ? ut(it(t3), 9007199254740991) : 0;
};
var ct = Math.max;
var lt = Math.min;
var ft = function(t3, e2) {
  var n3 = it(t3);
  return n3 < 0 ? ct(n3 + e2, 0) : lt(n3, e2);
};
var st = function(t3) {
  return function(e2, n3, r3) {
    var o3, i3 = g2(e2), u3 = at(i3.length), a3 = ft(r3, u3);
    if (t3 && n3 != n3) {
      for (; u3 > a3; ) if ((o3 = i3[a3++]) != o3) return true;
    } else for (; u3 > a3; a3++) if ((t3 || a3 in i3) && i3[a3] === n3) return t3 || a3 || 0;
    return !t3 && -1;
  };
};
var dt = { includes: st(true), indexOf: st(false) };
var vt = dt.indexOf;
var pt = function(t3, e2) {
  var n3, r3 = g2(t3), o3 = 0, i3 = [];
  for (n3 in r3) !S2(G, n3) && S2(r3, n3) && i3.push(n3);
  for (; e2.length > o3; ) S2(r3, n3 = e2[o3++]) && (~vt(i3, n3) || i3.push(n3));
  return i3;
};
var gt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var ht = gt.concat("length", "prototype");
var yt = { f: Object.getOwnPropertyNames || function(t3) {
  return pt(t3, ht);
} };
var mt = { f: Object.getOwnPropertySymbols };
var St = nt("Reflect", "ownKeys") || function(t3) {
  var e2 = yt.f(A2(t3)), n3 = mt.f;
  return n3 ? e2.concat(n3(t3)) : e2;
};
var xt = function(t3, e2) {
  for (var n3 = St(e2), r3 = R2.f, o3 = T2.f, i3 = 0; i3 < n3.length; i3++) {
    var u3 = n3[i3];
    S2(t3, u3) || r3(t3, u3, o3(e2, u3));
  }
};
var bt = /#|\.prototype\./;
var Et = function(t3, e2) {
  var n3 = Ot[wt(t3)];
  return n3 == At || n3 != Tt && ("function" == typeof e2 ? o2(e2) : !!e2);
};
var wt = Et.normalize = function(t3) {
  return String(t3).replace(bt, ".").toLowerCase();
};
var Ot = Et.data = {};
var Tt = Et.NATIVE = "N";
var At = Et.POLYFILL = "P";
var kt = Et;
var Rt = T2.f;
var It = function(t3, e2) {
  var n3, o3, i3, u3, a3, c3 = t3.target, l3 = t3.global, f3 = t3.stat;
  if (n3 = l3 ? r2 : f3 ? r2[c3] || j2(c3, {}) : (r2[c3] || {}).prototype) for (o3 in e2) {
    if (u3 = e2[o3], i3 = t3.noTargetGet ? (a3 = Rt(n3, o3)) && a3.value : n3[o3], !kt(l3 ? o3 : c3 + (f3 ? "." : "#") + o3, t3.forced) && void 0 !== i3) {
      if (typeof u3 == typeof i3) continue;
      xt(u3, i3);
    }
    (t3.sham || i3 && i3.sham) && I2(u3, "sham", true), Z(n3, o3, u3, t3);
  }
};
var jt = function(t3, e2) {
  var n3 = [][t3];
  return !!n3 && o2(function() {
    n3.call(null, e2 || function() {
      throw 1;
    }, 1);
  });
};
var Ct = Object.defineProperty;
var Lt = {};
var Pt = function(t3) {
  throw t3;
};
var Mt = function(t3, e2) {
  if (S2(Lt, t3)) return Lt[t3];
  e2 || (e2 = {});
  var n3 = [][t3], r3 = !!S2(e2, "ACCESSORS") && e2.ACCESSORS, u3 = S2(e2, 0) ? e2[0] : Pt, a3 = S2(e2, 1) ? e2[1] : void 0;
  return Lt[t3] = !!n3 && !o2(function() {
    if (r3 && !i2) return true;
    var t4 = { length: -1 };
    r3 ? Ct(t4, 1, { enumerable: true, get: Pt }) : t4[1] = 1, n3.call(t4, u3, a3);
  });
};
var _t = dt.indexOf;
var Dt = [].indexOf;
var Ut = !!Dt && 1 / [1].indexOf(1, -0) < 0;
var Nt = jt("indexOf");
var Ft = Mt("indexOf", { ACCESSORS: true, 1: 0 });
function Wt(t3, e2) {
  if (!(t3 instanceof e2)) throw new TypeError("Cannot call a class as a function");
}
function zt(t3, e2) {
  for (var n3 = 0; n3 < e2.length; n3++) {
    var r3 = e2[n3];
    r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t3, r3.key, r3);
  }
}
function $t(t3, e2, n3) {
  return e2 && zt(t3.prototype, e2), n3 && zt(t3, n3), t3;
}
It({ target: "Array", proto: true, forced: Ut || !Nt || !Ft }, { indexOf: function(t3) {
  return Ut ? Dt.apply(this, arguments) || 0 : _t(this, t3, arguments.length > 1 ? arguments[1] : void 0);
} });
var Bt = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "isInBrowser", value: function() {
    return "undefined" != typeof window;
  } }, { key: "isServer", value: function() {
    return "undefined" == typeof window;
  } }, { key: "getUA", value: function() {
    return t3.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
  } }, { key: "isMobile", value: function() {
    return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
  } }, { key: "isOpera", value: function() {
    return -1 !== navigator.userAgent.indexOf("Opera");
  } }, { key: "isIE", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && e2.indexOf("msie") > 0;
  } }, { key: "isIE9", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && e2.indexOf("msie 9.0") > 0;
  } }, { key: "isEdge", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && e2.indexOf("edge/") > 0;
  } }, { key: "isChrome", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && /chrome\/\d+/.test(e2) && !t3.isEdge();
  } }, { key: "isPhantomJS", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && /phantomjs/.test(e2);
  } }, { key: "isFirefox", value: function() {
    var e2 = t3.getUA();
    return "" !== e2 && /firefox/.test(e2);
  } }]), t3;
}();
var Yt = [].join;
var Gt = v2 != Object;
var Ht = jt("join", ",");
It({ target: "Array", proto: true, forced: Gt || !Ht }, { join: function(t3) {
  return Yt.call(g2(this), void 0 === t3 ? "," : t3);
} });
var Xt;
var Vt;
var Kt = function(t3) {
  return Object(p2(t3));
};
var qt = Array.isArray || function(t3) {
  return "Array" == s2(t3);
};
var Qt = !!Object.getOwnPropertySymbols && !o2(function() {
  return !String(Symbol());
});
var Jt = Qt && !Symbol.sham && "symbol" == typeof Symbol.iterator;
var Zt = F2("wks");
var te = r2.Symbol;
var ee = Jt ? te : te && te.withoutSetter || $2;
var ne = function(t3) {
  return S2(Zt, t3) || (Qt && S2(te, t3) ? Zt[t3] = te[t3] : Zt[t3] = ee("Symbol." + t3)), Zt[t3];
};
var re = ne("species");
var oe = function(t3, e2) {
  var n3;
  return qt(t3) && ("function" != typeof (n3 = t3.constructor) || n3 !== Array && !qt(n3.prototype) ? h3(n3) && null === (n3 = n3[re]) && (n3 = void 0) : n3 = void 0), new (void 0 === n3 ? Array : n3)(0 === e2 ? 0 : e2);
};
var ie = function(t3, e2, n3) {
  var r3 = y2(e2);
  r3 in t3 ? R2.f(t3, r3, l2(0, n3)) : t3[r3] = n3;
};
var ue = nt("navigator", "userAgent") || "";
var ae = r2.process;
var ce = ae && ae.versions;
var le = ce && ce.v8;
le ? Vt = (Xt = le.split("."))[0] + Xt[1] : ue && (!(Xt = ue.match(/Edge\/(\d+)/)) || Xt[1] >= 74) && (Xt = ue.match(/Chrome\/(\d+)/)) && (Vt = Xt[1]);
var fe = Vt && +Vt;
var se = ne("species");
var de = function(t3) {
  return fe >= 51 || !o2(function() {
    var e2 = [];
    return (e2.constructor = {})[se] = function() {
      return { foo: 1 };
    }, 1 !== e2[t3](Boolean).foo;
  });
};
var ve = de("splice");
var pe = Mt("splice", { ACCESSORS: true, 0: 0, 1: 2 });
var ge = Math.max;
var he = Math.min;
It({ target: "Array", proto: true, forced: !ve || !pe }, { splice: function(t3, e2) {
  var n3, r3, o3, i3, u3, a3, c3 = Kt(this), l3 = at(c3.length), f3 = ft(t3, l3), s3 = arguments.length;
  if (0 === s3 ? n3 = r3 = 0 : 1 === s3 ? (n3 = 0, r3 = l3 - f3) : (n3 = s3 - 2, r3 = he(ge(it(e2), 0), l3 - f3)), l3 + n3 - r3 > 9007199254740991) throw TypeError("Maximum allowed length exceeded");
  for (o3 = oe(c3, r3), i3 = 0; i3 < r3; i3++) (u3 = f3 + i3) in c3 && ie(o3, i3, c3[u3]);
  if (o3.length = r3, n3 < r3) {
    for (i3 = f3; i3 < l3 - r3; i3++) a3 = i3 + n3, (u3 = i3 + r3) in c3 ? c3[a3] = c3[u3] : delete c3[a3];
    for (i3 = l3; i3 > l3 - r3 + n3; i3--) delete c3[i3 - 1];
  } else if (n3 > r3) for (i3 = l3 - r3; i3 > f3; i3--) a3 = i3 + n3 - 1, (u3 = i3 + r3 - 1) in c3 ? c3[a3] = c3[u3] : delete c3[a3];
  for (i3 = 0; i3 < n3; i3++) c3[i3 + f3] = arguments[i3 + 2];
  return c3.length = l3 - r3 + n3, o3;
} });
var ye = {};
ye[ne("toStringTag")] = "z";
var me = "[object z]" === String(ye);
var Se = ne("toStringTag");
var xe = "Arguments" == s2(/* @__PURE__ */ function() {
  return arguments;
}());
var be = me ? s2 : function(t3) {
  var e2, n3, r3;
  return void 0 === t3 ? "Undefined" : null === t3 ? "Null" : "string" == typeof (n3 = function(t4, e3) {
    try {
      return t4[e3];
    } catch (t5) {
    }
  }(e2 = Object(t3), Se)) ? n3 : xe ? s2(e2) : "Object" == (r3 = s2(e2)) && "function" == typeof e2.callee ? "Arguments" : r3;
};
var Ee = me ? {}.toString : function() {
  return "[object " + be(this) + "]";
};
me || Z(Object.prototype, "toString", Ee, { unsafe: true });
var we = function() {
  var t3 = A2(this), e2 = "";
  return t3.global && (e2 += "g"), t3.ignoreCase && (e2 += "i"), t3.multiline && (e2 += "m"), t3.dotAll && (e2 += "s"), t3.unicode && (e2 += "u"), t3.sticky && (e2 += "y"), e2;
};
function Oe(t3, e2) {
  return RegExp(t3, e2);
}
var Te;
var Ae;
var ke = { UNSUPPORTED_Y: o2(function() {
  var t3 = Oe("a", "y");
  return t3.lastIndex = 2, null != t3.exec("abcd");
}), BROKEN_CARET: o2(function() {
  var t3 = Oe("^r", "gy");
  return t3.lastIndex = 2, null != t3.exec("str");
}) };
var Re = RegExp.prototype.exec;
var Ie = String.prototype.replace;
var je = Re;
var Ce = (Te = /a/, Ae = /b*/g, Re.call(Te, "a"), Re.call(Ae, "a"), 0 !== Te.lastIndex || 0 !== Ae.lastIndex);
var Le = ke.UNSUPPORTED_Y || ke.BROKEN_CARET;
var Pe = void 0 !== /()??/.exec("")[1];
(Ce || Pe || Le) && (je = function(t3) {
  var e2, n3, r3, o3, i3 = this, u3 = Le && i3.sticky, a3 = we.call(i3), c3 = i3.source, l3 = 0, f3 = t3;
  return u3 && (-1 === (a3 = a3.replace("y", "")).indexOf("g") && (a3 += "g"), f3 = String(t3).slice(i3.lastIndex), i3.lastIndex > 0 && (!i3.multiline || i3.multiline && "\n" !== t3[i3.lastIndex - 1]) && (c3 = "(?: " + c3 + ")", f3 = " " + f3, l3++), n3 = new RegExp("^(?:" + c3 + ")", a3)), Pe && (n3 = new RegExp("^" + c3 + "$(?!\\s)", a3)), Ce && (e2 = i3.lastIndex), r3 = Re.call(u3 ? n3 : i3, f3), u3 ? r3 ? (r3.input = r3.input.slice(l3), r3[0] = r3[0].slice(l3), r3.index = i3.lastIndex, i3.lastIndex += r3[0].length) : i3.lastIndex = 0 : Ce && r3 && (i3.lastIndex = i3.global ? r3.index + r3[0].length : e2), Pe && r3 && r3.length > 1 && Ie.call(r3[0], n3, function() {
    for (o3 = 1; o3 < arguments.length - 2; o3++) void 0 === arguments[o3] && (r3[o3] = void 0);
  }), r3;
});
var Me = je;
It({ target: "RegExp", proto: true, forced: /./.exec !== Me }, { exec: Me });
var _e = RegExp.prototype;
var De = _e.toString;
var Ue = o2(function() {
  return "/a/b" != De.call({ source: "a", flags: "b" });
});
var Ne = "toString" != De.name;
(Ue || Ne) && Z(RegExp.prototype, "toString", function() {
  var t3 = A2(this), e2 = String(t3.source), n3 = t3.flags;
  return "/" + e2 + "/" + String(void 0 === n3 && t3 instanceof RegExp && !("flags" in _e) ? we.call(t3) : n3);
}, { unsafe: true });
var Fe = ne("species");
var We = !o2(function() {
  var t3 = /./;
  return t3.exec = function() {
    var t4 = [];
    return t4.groups = { a: "7" }, t4;
  }, "7" !== "".replace(t3, "$<a>");
});
var ze = "$0" === "a".replace(/./, "$0");
var $e = ne("replace");
var Be = !!/./[$e] && "" === /./[$e]("a", "$0");
var Ye = !o2(function() {
  var t3 = /(?:)/, e2 = t3.exec;
  t3.exec = function() {
    return e2.apply(this, arguments);
  };
  var n3 = "ab".split(t3);
  return 2 !== n3.length || "a" !== n3[0] || "b" !== n3[1];
});
var Ge = function(t3, e2, n3, r3) {
  var i3 = ne(t3), u3 = !o2(function() {
    var e3 = {};
    return e3[i3] = function() {
      return 7;
    }, 7 != ""[t3](e3);
  }), a3 = u3 && !o2(function() {
    var e3 = false, n4 = /a/;
    return "split" === t3 && ((n4 = {}).constructor = {}, n4.constructor[Fe] = function() {
      return n4;
    }, n4.flags = "", n4[i3] = /./[i3]), n4.exec = function() {
      return e3 = true, null;
    }, n4[i3](""), !e3;
  });
  if (!u3 || !a3 || "replace" === t3 && (!We || !ze || Be) || "split" === t3 && !Ye) {
    var c3 = /./[i3], l3 = n3(i3, ""[t3], function(t4, e3, n4, r4, o3) {
      return e3.exec === Me ? u3 && !o3 ? { done: true, value: c3.call(e3, n4, r4) } : { done: true, value: t4.call(n4, e3, r4) } : { done: false };
    }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f3 = l3[0], s3 = l3[1];
    Z(String.prototype, t3, f3), Z(RegExp.prototype, i3, 2 == e2 ? function(t4, e3) {
      return s3.call(t4, this, e3);
    } : function(t4) {
      return s3.call(t4, this);
    });
  }
  r3 && I2(RegExp.prototype[i3], "sham", true);
};
var He = ne("match");
var Xe = function(t3) {
  var e2;
  return h3(t3) && (void 0 !== (e2 = t3[He]) ? !!e2 : "RegExp" == s2(t3));
};
var Ve = function(t3) {
  if ("function" != typeof t3) throw TypeError(String(t3) + " is not a function");
  return t3;
};
var Ke = ne("species");
var qe = function(t3) {
  return function(e2, n3) {
    var r3, o3, i3 = String(p2(e2)), u3 = it(n3), a3 = i3.length;
    return u3 < 0 || u3 >= a3 ? t3 ? "" : void 0 : (r3 = i3.charCodeAt(u3)) < 55296 || r3 > 56319 || u3 + 1 === a3 || (o3 = i3.charCodeAt(u3 + 1)) < 56320 || o3 > 57343 ? t3 ? i3.charAt(u3) : r3 : t3 ? i3.slice(u3, u3 + 2) : o3 - 56320 + (r3 - 55296 << 10) + 65536;
  };
};
var Qe = { codeAt: qe(false), charAt: qe(true) };
var Je = Qe.charAt;
var Ze = function(t3, e2, n3) {
  return e2 + (n3 ? Je(t3, e2).length : 1);
};
var tn = function(t3, e2) {
  var n3 = t3.exec;
  if ("function" == typeof n3) {
    var r3 = n3.call(t3, e2);
    if ("object" != typeof r3) throw TypeError("RegExp exec method returned something other than an Object or null");
    return r3;
  }
  if ("RegExp" !== s2(t3)) throw TypeError("RegExp#exec called on incompatible receiver");
  return Me.call(t3, e2);
};
var en = [].push;
var nn = Math.min;
var rn = !o2(function() {
  return !RegExp(4294967295, "y");
});
Ge("split", 2, function(t3, e2, n3) {
  var r3;
  return r3 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t4, n4) {
    var r4 = String(p2(this)), o3 = void 0 === n4 ? 4294967295 : n4 >>> 0;
    if (0 === o3) return [];
    if (void 0 === t4) return [r4];
    if (!Xe(t4)) return e2.call(r4, t4, o3);
    for (var i3, u3, a3, c3 = [], l3 = (t4.ignoreCase ? "i" : "") + (t4.multiline ? "m" : "") + (t4.unicode ? "u" : "") + (t4.sticky ? "y" : ""), f3 = 0, s3 = new RegExp(t4.source, l3 + "g"); (i3 = Me.call(s3, r4)) && !((u3 = s3.lastIndex) > f3 && (c3.push(r4.slice(f3, i3.index)), i3.length > 1 && i3.index < r4.length && en.apply(c3, i3.slice(1)), a3 = i3[0].length, f3 = u3, c3.length >= o3)); ) s3.lastIndex === i3.index && s3.lastIndex++;
    return f3 === r4.length ? !a3 && s3.test("") || c3.push("") : c3.push(r4.slice(f3)), c3.length > o3 ? c3.slice(0, o3) : c3;
  } : "0".split(void 0, 0).length ? function(t4, n4) {
    return void 0 === t4 && 0 === n4 ? [] : e2.call(this, t4, n4);
  } : e2, [function(e3, n4) {
    var o3 = p2(this), i3 = null == e3 ? void 0 : e3[t3];
    return void 0 !== i3 ? i3.call(e3, o3, n4) : r3.call(String(o3), e3, n4);
  }, function(t4, o3) {
    var i3 = n3(r3, t4, this, o3, r3 !== e2);
    if (i3.done) return i3.value;
    var u3 = A2(t4), a3 = String(this), c3 = function(t5, e3) {
      var n4, r4 = A2(t5).constructor;
      return void 0 === r4 || null == (n4 = A2(r4)[Ke]) ? e3 : Ve(n4);
    }(u3, RegExp), l3 = u3.unicode, f3 = (u3.ignoreCase ? "i" : "") + (u3.multiline ? "m" : "") + (u3.unicode ? "u" : "") + (rn ? "y" : "g"), s3 = new c3(rn ? u3 : "^(?:" + u3.source + ")", f3), d3 = void 0 === o3 ? 4294967295 : o3 >>> 0;
    if (0 === d3) return [];
    if (0 === a3.length) return null === tn(s3, a3) ? [a3] : [];
    for (var v3 = 0, p3 = 0, g3 = []; p3 < a3.length; ) {
      s3.lastIndex = rn ? p3 : 0;
      var h4, y3 = tn(s3, rn ? a3 : a3.slice(p3));
      if (null === y3 || (h4 = nn(at(s3.lastIndex + (rn ? 0 : p3)), a3.length)) === v3) p3 = Ze(a3, p3, l3);
      else {
        if (g3.push(a3.slice(v3, p3)), g3.length === d3) return g3;
        for (var m3 = 1; m3 <= y3.length - 1; m3++) if (g3.push(y3[m3]), g3.length === d3) return g3;
        p3 = v3 = h4;
      }
    }
    return g3.push(a3.slice(v3)), g3;
  }];
}, !rn);
var on = "	\n\v\f\r                　\u2028\u2029\uFEFF";
var un = "[" + on + "]";
var an = RegExp("^" + un + un + "*");
var cn = RegExp(un + un + "*$");
var ln = function(t3) {
  return function(e2) {
    var n3 = String(p2(e2));
    return 1 & t3 && (n3 = n3.replace(an, "")), 2 & t3 && (n3 = n3.replace(cn, "")), n3;
  };
};
var fn2 = { start: ln(1), end: ln(2), trim: ln(3) };
var sn = fn2.trim;
It({ target: "String", proto: true, forced: function(t3) {
  return o2(function() {
    return !!on[t3]() || "​᠎" != "​᠎"[t3]() || on[t3].name !== t3;
  });
}("trim") }, { trim: function() {
  return sn(this);
} });
var dn = de("slice");
var vn = Mt("slice", { ACCESSORS: true, 0: 0, 1: 2 });
var pn = ne("species");
var gn = [].slice;
var hn = Math.max;
It({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t3, e2) {
  var n3, r3, o3, i3 = g2(this), u3 = at(i3.length), a3 = ft(t3, u3), c3 = ft(void 0 === e2 ? u3 : e2, u3);
  if (qt(i3) && ("function" != typeof (n3 = i3.constructor) || n3 !== Array && !qt(n3.prototype) ? h3(n3) && null === (n3 = n3[pn]) && (n3 = void 0) : n3 = void 0, n3 === Array || void 0 === n3)) return gn.call(i3, a3, c3);
  for (r3 = new (void 0 === n3 ? Array : n3)(hn(c3 - a3, 0)), o3 = 0; a3 < c3; a3++, o3++) a3 in i3 && ie(r3, o3, i3[a3]);
  return r3.length = o3, r3;
} });
var yn = Object.keys || function(t3) {
  return pt(t3, gt);
};
var mn = o2(function() {
  yn(1);
});
It({ target: "Object", stat: true, forced: mn }, { keys: function(t3) {
  return yn(Kt(t3));
} });
var Sn;
var xn = function(t3) {
  if (Xe(t3)) throw TypeError("The method doesn't accept regular expressions");
  return t3;
};
var bn = ne("match");
var En = T2.f;
var wn = "".startsWith;
var On = Math.min;
var Tn = function(t3) {
  var e2 = /./;
  try {
    "/./"[t3](e2);
  } catch (n3) {
    try {
      return e2[bn] = false, "/./"[t3](e2);
    } catch (t4) {
    }
  }
  return false;
}("startsWith");
var An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
function kn(t3) {
  return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
    return typeof t4;
  } : function(t4) {
    return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
  })(t3);
}
It({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t3) {
  var e2 = String(p2(this));
  xn(t3);
  var n3 = at(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r3 = String(t3);
  return wn ? wn.call(e2, r3, n3) : e2.slice(n3, n3 + r3.length) === r3;
} });
var jn = function(t3) {
  return "string" == typeof t3;
};
var Mn = function(t3) {
  return null !== t3 && "object" === kn(t3);
};
var Fn = Array.isArray;
var Vn = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "isWindow", value: function(t4) {
    return t4 === window;
  } }, { key: "addEventListener", value: function(t4, e2, n3) {
    var r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t4 && e2 && n3 && t4.addEventListener(e2, n3, r3);
  } }, { key: "removeEventListener", value: function(t4, e2, n3) {
    var r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t4 && e2 && n3 && t4.removeEventListener(e2, n3, r3);
  } }, { key: "triggerDragEvent", value: function(e2, n3) {
    var r3 = false, o3 = function(t4) {
      var e3;
      null === (e3 = n3.drag) || void 0 === e3 || e3.call(n3, t4);
    }, i3 = function e3(i4) {
      var u3;
      t3.removeEventListener(document, "mousemove", o3), t3.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r3 = false, null === (u3 = n3.end) || void 0 === u3 || u3.call(n3, i4);
    };
    t3.addEventListener(e2, "mousedown", function(e3) {
      var u3;
      r3 || (document.onselectstart = function() {
        return false;
      }, document.ondragstart = function() {
        return false;
      }, t3.addEventListener(document, "mousemove", o3), t3.addEventListener(document, "mouseup", i3), r3 = true, null === (u3 = n3.start) || void 0 === u3 || u3.call(n3, e3));
    });
  } }, { key: "getBoundingClientRect", value: function(t4) {
    return t4 && Mn(t4) && 1 === t4.nodeType ? t4.getBoundingClientRect() : null;
  } }, { key: "hasClass", value: function(t4, e2) {
    return !!(t4 && Mn(t4) && jn(e2) && 1 === t4.nodeType) && t4.classList.contains(e2.trim());
  } }, { key: "addClass", value: function(e2, n3) {
    if (e2 && Mn(e2) && jn(n3) && 1 === e2.nodeType && (n3 = n3.trim(), !t3.hasClass(e2, n3))) {
      var r3 = e2.className;
      e2.className = r3 ? r3 + " " + n3 : n3;
    }
  } }, { key: "removeClass", value: function(t4, e2) {
    if (t4 && Mn(t4) && jn(e2) && 1 === t4.nodeType && "string" == typeof t4.className) {
      e2 = e2.trim();
      for (var n3 = t4.className.trim().split(" "), r3 = n3.length - 1; r3 >= 0; r3--) n3[r3] = n3[r3].trim(), n3[r3] && n3[r3] !== e2 || n3.splice(r3, 1);
      t4.className = n3.join(" ");
    }
  } }, { key: "toggleClass", value: function(t4, e2, n3) {
    t4 && Mn(t4) && jn(e2) && 1 === t4.nodeType && t4.classList.toggle(e2, n3);
  } }, { key: "replaceClass", value: function(e2, n3, r3) {
    e2 && Mn(e2) && jn(n3) && jn(r3) && 1 === e2.nodeType && (n3 = n3.trim(), r3 = r3.trim(), t3.removeClass(e2, n3), t3.addClass(e2, r3));
  } }, { key: "getScrollTop", value: function(t4) {
    var e2 = "scrollTop" in t4 ? t4.scrollTop : t4.pageYOffset;
    return Math.max(e2, 0);
  } }, { key: "setScrollTop", value: function(t4, e2) {
    "scrollTop" in t4 ? t4.scrollTop = e2 : t4.scrollTo(t4.scrollX, e2);
  } }, { key: "getRootScrollTop", value: function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } }, { key: "setRootScrollTop", value: function(e2) {
    t3.setScrollTop(window, e2), t3.setScrollTop(document.body, e2);
  } }, { key: "getElementTop", value: function(e2, n3) {
    if (t3.isWindow(e2)) return 0;
    var r3 = n3 ? t3.getScrollTop(n3) : t3.getRootScrollTop();
    return e2.getBoundingClientRect().top + r3;
  } }, { key: "getVisibleHeight", value: function(e2) {
    return t3.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
  } }, { key: "isHidden", value: function(t4) {
    if (!t4) return false;
    var e2 = window.getComputedStyle(t4), n3 = "none" === e2.display, r3 = null === t4.offsetParent && "fixed" !== e2.position;
    return n3 || r3;
  } }, { key: "triggerEvent", value: function(t4, e2) {
    if ("createEvent" in document) {
      var n3 = document.createEvent("HTMLEvents");
      n3.initEvent(e2, false, true), t4.dispatchEvent(n3);
    }
  } }, { key: "calcAngle", value: function(t4, e2) {
    var n3 = t4.getBoundingClientRect(), r3 = n3.left + n3.width / 2, o3 = n3.top + n3.height / 2, i3 = Math.abs(r3 - e2.clientX), u3 = Math.abs(o3 - e2.clientY), a3 = u3 / Math.sqrt(Math.pow(i3, 2) + Math.pow(u3, 2)), c3 = Math.acos(a3), l3 = Math.floor(180 / (Math.PI / c3));
    return e2.clientX > r3 && e2.clientY > o3 && (l3 = 180 - l3), e2.clientX == r3 && e2.clientY > o3 && (l3 = 180), e2.clientX > r3 && e2.clientY == o3 && (l3 = 90), e2.clientX < r3 && e2.clientY > o3 && (l3 = 180 + l3), e2.clientX < r3 && e2.clientY == o3 && (l3 = 270), e2.clientX < r3 && e2.clientY < o3 && (l3 = 360 - l3), l3;
  } }, { key: "querySelector", value: function(t4, e2) {
    return e2 ? e2.querySelector(t4) : document.querySelector(t4);
  } }, { key: "createElement", value: function(t4) {
    for (var e2 = document.createElement(t4), n3 = arguments.length, r3 = new Array(n3 > 1 ? n3 - 1 : 0), o3 = 1; o3 < n3; o3++) r3[o3 - 1] = arguments[o3];
    for (var i3 = 0; i3 < r3.length; i3++) r3[i3] && e2.classList.add(r3[i3]);
    return e2;
  } }, { key: "appendChild", value: function(t4) {
    for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++) t4.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
  } }, { key: "getWindow", value: function(t4) {
    if ("[object Window]" !== t4.toString()) {
      var e2 = t4.ownerDocument;
      return e2 && e2.defaultView || window;
    }
    return t4;
  } }, { key: "isElement", value: function(t4) {
    return t4 instanceof this.getWindow(t4).Element || t4 instanceof Element;
  } }, { key: "isHTMLElement", value: function(t4) {
    return t4 instanceof this.getWindow(t4).HTMLElement || t4 instanceof HTMLElement;
  } }, { key: "isShadowRoot", value: function(t4) {
    return "undefined" != typeof ShadowRoot && (t4 instanceof this.getWindow(t4).ShadowRoot || t4 instanceof ShadowRoot);
  } }, { key: "getWindowScroll", value: function(t4) {
    var e2 = this.getWindow(t4);
    return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
  } }]), t3;
}();
var Kn = Math.floor;
var qn = "".replace;
var Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var Jn = /\$([$&'`]|\d\d?)/g;
var Zn = function(t3, e2, n3, r3, o3, i3) {
  var u3 = n3 + t3.length, a3 = r3.length, c3 = Jn;
  return void 0 !== o3 && (o3 = Kt(o3), c3 = Qn), qn.call(i3, c3, function(i4, c4) {
    var l3;
    switch (c4.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return t3;
      case "`":
        return e2.slice(0, n3);
      case "'":
        return e2.slice(u3);
      case "<":
        l3 = o3[c4.slice(1, -1)];
        break;
      default:
        var f3 = +c4;
        if (0 === f3) return i4;
        if (f3 > a3) {
          var s3 = Kn(f3 / 10);
          return 0 === s3 ? i4 : s3 <= a3 ? void 0 === r3[s3 - 1] ? c4.charAt(1) : r3[s3 - 1] + c4.charAt(1) : i4;
        }
        l3 = r3[f3 - 1];
    }
    return void 0 === l3 ? "" : l3;
  });
};
var tr = Math.max;
var er = Math.min;
Ge("replace", 2, function(t3, e2, n3, r3) {
  var o3 = r3.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i3 = r3.REPLACE_KEEPS_$0, u3 = o3 ? "$" : "$0";
  return [function(n4, r4) {
    var o4 = p2(this), i4 = null == n4 ? void 0 : n4[t3];
    return void 0 !== i4 ? i4.call(n4, o4, r4) : e2.call(String(o4), n4, r4);
  }, function(t4, r4) {
    if (!o3 && i3 || "string" == typeof r4 && -1 === r4.indexOf(u3)) {
      var a3 = n3(e2, t4, this, r4);
      if (a3.done) return a3.value;
    }
    var c3 = A2(t4), l3 = String(this), f3 = "function" == typeof r4;
    f3 || (r4 = String(r4));
    var s3 = c3.global;
    if (s3) {
      var d3 = c3.unicode;
      c3.lastIndex = 0;
    }
    for (var v3 = []; ; ) {
      var p3 = tn(c3, l3);
      if (null === p3) break;
      if (v3.push(p3), !s3) break;
      "" === String(p3[0]) && (c3.lastIndex = Ze(l3, at(c3.lastIndex), d3));
    }
    for (var g3, h4 = "", y3 = 0, m3 = 0; m3 < v3.length; m3++) {
      p3 = v3[m3];
      for (var S3 = String(p3[0]), x3 = tr(er(it(p3.index), l3.length), 0), b3 = [], E3 = 1; E3 < p3.length; E3++) b3.push(void 0 === (g3 = p3[E3]) ? g3 : String(g3));
      var w3 = p3.groups;
      if (f3) {
        var O3 = [S3].concat(b3, x3, l3);
        void 0 !== w3 && O3.push(w3);
        var T3 = String(r4.apply(void 0, O3));
      } else T3 = Zn(S3, l3, x3, b3, w3, r4);
      x3 >= y3 && (h4 += l3.slice(y3, x3) + T3, y3 = x3 + S3.length);
    }
    return h4 + l3.slice(y3);
  }];
});
var nr = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "camelize", value: function(t4) {
    return t4.replace(/-(\w)/g, function(t5, e2) {
      return e2 ? e2.toUpperCase() : "";
    });
  } }, { key: "capitalize", value: function(t4) {
    return t4.charAt(0).toUpperCase() + t4.slice(1);
  } }]), t3;
}();
var rr = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "_clone", value: function() {
  } }]), t3;
}();
var or = ne("isConcatSpreadable");
var ir = fe >= 51 || !o2(function() {
  var t3 = [];
  return t3[or] = false, t3.concat()[0] !== t3;
});
var ur = de("concat");
var ar = function(t3) {
  if (!h3(t3)) return false;
  var e2 = t3[or];
  return void 0 !== e2 ? !!e2 : qt(t3);
};
It({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t3) {
  var e2, n3, r3, o3, i3, u3 = Kt(this), a3 = oe(u3, 0), c3 = 0;
  for (e2 = -1, r3 = arguments.length; e2 < r3; e2++) if (ar(i3 = -1 === e2 ? u3 : arguments[e2])) {
    if (c3 + (o3 = at(i3.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");
    for (n3 = 0; n3 < o3; n3++, c3++) n3 in i3 && ie(a3, c3, i3[n3]);
  } else {
    if (c3 >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
    ie(a3, c3++, i3);
  }
  return a3.length = c3, a3;
} });
var cr;
var lr = function(t3, e2, n3) {
  if (Ve(t3), void 0 === e2) return t3;
  switch (n3) {
    case 0:
      return function() {
        return t3.call(e2);
      };
    case 1:
      return function(n4) {
        return t3.call(e2, n4);
      };
    case 2:
      return function(n4, r3) {
        return t3.call(e2, n4, r3);
      };
    case 3:
      return function(n4, r3, o3) {
        return t3.call(e2, n4, r3, o3);
      };
  }
  return function() {
    return t3.apply(e2, arguments);
  };
};
var fr = [].push;
var sr = function(t3) {
  var e2 = 1 == t3, n3 = 2 == t3, r3 = 3 == t3, o3 = 4 == t3, i3 = 6 == t3, u3 = 7 == t3, a3 = 5 == t3 || i3;
  return function(c3, l3, f3, s3) {
    for (var d3, p3, g3 = Kt(c3), h4 = v2(g3), y3 = lr(l3, f3, 3), m3 = at(h4.length), S3 = 0, x3 = s3 || oe, b3 = e2 ? x3(c3, m3) : n3 || u3 ? x3(c3, 0) : void 0; m3 > S3; S3++) if ((a3 || S3 in h4) && (p3 = y3(d3 = h4[S3], S3, g3), t3)) if (e2) b3[S3] = p3;
    else if (p3) switch (t3) {
      case 3:
        return true;
      case 5:
        return d3;
      case 6:
        return S3;
      case 2:
        fr.call(b3, d3);
    }
    else switch (t3) {
      case 4:
        return false;
      case 7:
        fr.call(b3, d3);
    }
    return i3 ? -1 : r3 || o3 ? o3 : b3;
  };
};
var dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) };
var vr = i2 ? Object.defineProperties : function(t3, e2) {
  A2(t3);
  for (var n3, r3 = yn(e2), o3 = r3.length, i3 = 0; o3 > i3; ) R2.f(t3, n3 = r3[i3++], e2[n3]);
  return t3;
};
var pr = nt("document", "documentElement");
var gr = Y2("IE_PROTO");
var hr = function() {
};
var yr = function(t3) {
  return "<script>" + t3 + "<\/script>";
};
var mr = function() {
  try {
    cr = document.domain && new ActiveXObject("htmlfile");
  } catch (t4) {
  }
  var t3, e2;
  mr = cr ? function(t4) {
    t4.write(yr("")), t4.close();
    var e3 = t4.parentWindow.Object;
    return t4 = null, e3;
  }(cr) : ((e2 = E2("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t3 = e2.contentWindow.document).open(), t3.write(yr("document.F=Object")), t3.close(), t3.F);
  for (var n3 = gt.length; n3--; ) delete mr.prototype[gt[n3]];
  return mr();
};
G[gr] = true;
var Sr = Object.create || function(t3, e2) {
  var n3;
  return null !== t3 ? (hr.prototype = A2(t3), n3 = new hr(), hr.prototype = null, n3[gr] = t3) : n3 = mr(), void 0 === e2 ? n3 : vr(n3, e2);
};
var xr = ne("unscopables");
var br = Array.prototype;
null == br[xr] && R2.f(br, xr, { configurable: true, value: Sr(null) });
var Er = function(t3) {
  br[xr][t3] = true;
};
var wr = dr.find;
var Or = true;
var Tr = Mt("find");
"find" in [] && Array(1).find(function() {
  Or = false;
}), It({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t3) {
  return wr(this, t3, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("find");
var Ar = dr.findIndex;
var kr = true;
var Rr = Mt("findIndex");
"findIndex" in [] && Array(1).findIndex(function() {
  kr = false;
}), It({ target: "Array", proto: true, forced: kr || !Rr }, { findIndex: function(t3) {
  return Ar(this, t3, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("findIndex");
var Ir = function(t3, e2, n3, r3, o3, i3, u3, a3) {
  for (var c3, l3 = o3, f3 = 0, s3 = !!u3 && lr(u3, a3, 3); f3 < r3; ) {
    if (f3 in n3) {
      if (c3 = s3 ? s3(n3[f3], f3, e2) : n3[f3], i3 > 0 && qt(c3)) l3 = Ir(t3, e2, c3, at(c3.length), l3, i3 - 1) - 1;
      else {
        if (l3 >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
        t3[l3] = c3;
      }
      l3++;
    }
    f3++;
  }
  return l3;
};
var jr = Ir;
It({ target: "Array", proto: true }, { flat: function() {
  var t3 = arguments.length ? arguments[0] : void 0, e2 = Kt(this), n3 = at(e2.length), r3 = oe(e2, 0);
  return r3.length = jr(r3, e2, e2, n3, 0, void 0 === t3 ? 1 : it(t3)), r3;
} });
var Cr = function(t3) {
  var e2 = t3.return;
  if (void 0 !== e2) return A2(e2.call(t3)).value;
};
var Lr = function(t3, e2, n3, r3) {
  try {
    return r3 ? e2(A2(n3)[0], n3[1]) : e2(n3);
  } catch (e3) {
    throw Cr(t3), e3;
  }
};
var Pr = {};
var Mr = ne("iterator");
var _r = Array.prototype;
var Dr = function(t3) {
  return void 0 !== t3 && (Pr.Array === t3 || _r[Mr] === t3);
};
var Ur = ne("iterator");
var Nr = function(t3) {
  if (null != t3) return t3[Ur] || t3["@@iterator"] || Pr[be(t3)];
};
var Fr = ne("iterator");
var Wr = false;
try {
  zr = 0, $r = { next: function() {
    return { done: !!zr++ };
  }, return: function() {
    Wr = true;
  } };
  $r[Fr] = function() {
    return this;
  }, Array.from($r, function() {
    throw 2;
  });
} catch (t3) {
}
var zr;
var $r;
var Br = function(t3, e2) {
  if (!e2 && !Wr) return false;
  var n3 = false;
  try {
    var r3 = {};
    r3[Fr] = function() {
      return { next: function() {
        return { done: n3 = true };
      } };
    }, t3(r3);
  } catch (t4) {
  }
  return n3;
};
var Yr = !Br(function(t3) {
  Array.from(t3);
});
It({ target: "Array", stat: true, forced: Yr }, { from: function(t3) {
  var e2, n3, r3, o3, i3, u3, a3 = Kt(t3), c3 = "function" == typeof this ? this : Array, l3 = arguments.length, f3 = l3 > 1 ? arguments[1] : void 0, s3 = void 0 !== f3, d3 = Nr(a3), v3 = 0;
  if (s3 && (f3 = lr(f3, l3 > 2 ? arguments[2] : void 0, 2)), null == d3 || c3 == Array && Dr(d3)) for (n3 = new c3(e2 = at(a3.length)); e2 > v3; v3++) u3 = s3 ? f3(a3[v3], v3) : a3[v3], ie(n3, v3, u3);
  else for (i3 = (o3 = d3.call(a3)).next, n3 = new c3(); !(r3 = i3.call(o3)).done; v3++) u3 = s3 ? Lr(o3, f3, [r3.value, v3], true) : r3.value, ie(n3, v3, u3);
  return n3.length = v3, n3;
} });
var Gr = function(t3) {
  return function(e2, n3, r3, o3) {
    Ve(n3);
    var i3 = Kt(e2), u3 = v2(i3), a3 = at(i3.length), c3 = t3 ? a3 - 1 : 0, l3 = t3 ? -1 : 1;
    if (r3 < 2) for (; ; ) {
      if (c3 in u3) {
        o3 = u3[c3], c3 += l3;
        break;
      }
      if (c3 += l3, t3 ? c3 < 0 : a3 <= c3) throw TypeError("Reduce of empty array with no initial value");
    }
    for (; t3 ? c3 >= 0 : a3 > c3; c3 += l3) c3 in u3 && (o3 = n3(o3, u3[c3], c3, i3));
    return o3;
  };
};
var Hr = { left: Gr(false), right: Gr(true) };
var Xr = "process" == s2(r2.process);
var Vr = Hr.left;
var Kr = jt("reduce");
var qr = Mt("reduce", { 1: 0 });
It({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe > 79 && fe < 83 }, { reduce: function(t3) {
  return Vr(this, t3, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("flat");
var Qr;
var Jr;
var Zr;
var to = !o2(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var eo = e(function(t3) {
  var e2 = R2.f, n3 = $2("meta"), r3 = 0, o3 = Object.isExtensible || function() {
    return true;
  }, i3 = function(t4) {
    e2(t4, n3, { value: { objectID: "O" + ++r3, weakData: {} } });
  }, u3 = t3.exports = { REQUIRED: false, fastKey: function(t4, e3) {
    if (!h3(t4)) return "symbol" == typeof t4 ? t4 : ("string" == typeof t4 ? "S" : "P") + t4;
    if (!S2(t4, n3)) {
      if (!o3(t4)) return "F";
      if (!e3) return "E";
      i3(t4);
    }
    return t4[n3].objectID;
  }, getWeakData: function(t4, e3) {
    if (!S2(t4, n3)) {
      if (!o3(t4)) return true;
      if (!e3) return false;
      i3(t4);
    }
    return t4[n3].weakData;
  }, onFreeze: function(t4) {
    return to && u3.REQUIRED && o3(t4) && !S2(t4, n3) && i3(t4), t4;
  } };
  G[n3] = true;
});
var no = function(t3, e2) {
  this.stopped = t3, this.result = e2;
};
var ro = function(t3, e2, n3) {
  var r3, o3, i3, u3, a3, c3, l3, f3 = n3 && n3.that, s3 = !(!n3 || !n3.AS_ENTRIES), d3 = !(!n3 || !n3.IS_ITERATOR), v3 = !(!n3 || !n3.INTERRUPTED), p3 = lr(e2, f3, 1 + s3 + v3), g3 = function(t4) {
    return r3 && Cr(r3), new no(true, t4);
  }, h4 = function(t4) {
    return s3 ? (A2(t4), v3 ? p3(t4[0], t4[1], g3) : p3(t4[0], t4[1])) : v3 ? p3(t4, g3) : p3(t4);
  };
  if (d3) r3 = t3;
  else {
    if ("function" != typeof (o3 = Nr(t3))) throw TypeError("Target is not iterable");
    if (Dr(o3)) {
      for (i3 = 0, u3 = at(t3.length); u3 > i3; i3++) if ((a3 = h4(t3[i3])) && a3 instanceof no) return a3;
      return new no(false);
    }
    r3 = o3.call(t3);
  }
  for (c3 = r3.next; !(l3 = c3.call(r3)).done; ) {
    try {
      a3 = h4(l3.value);
    } catch (t4) {
      throw Cr(r3), t4;
    }
    if ("object" == typeof a3 && a3 && a3 instanceof no) return a3;
  }
  return new no(false);
};
var oo = function(t3, e2, n3) {
  if (!(t3 instanceof e2)) throw TypeError("Incorrect " + (n3 ? n3 + " " : "") + "invocation");
  return t3;
};
var io = R2.f;
var uo = ne("toStringTag");
var ao = function(t3, e2, n3) {
  t3 && !S2(t3 = n3 ? t3 : t3.prototype, uo) && io(t3, uo, { configurable: true, value: e2 });
};
var co = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t3, e2 = false, n3 = {};
  try {
    (t3 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n3, []), e2 = n3 instanceof Array;
  } catch (t4) {
  }
  return function(n4, r3) {
    return A2(n4), function(t4) {
      if (!h3(t4) && null !== t4) throw TypeError("Can't set " + String(t4) + " as a prototype");
    }(r3), e2 ? t3.call(n4, r3) : n4.__proto__ = r3, n4;
  };
}() : void 0);
var lo = function(t3, e2, n3) {
  for (var r3 in e2) Z(t3, r3, e2[r3], n3);
  return t3;
};
var fo = !o2(function() {
  function t3() {
  }
  return t3.prototype.constructor = null, Object.getPrototypeOf(new t3()) !== t3.prototype;
});
var so = Y2("IE_PROTO");
var vo = Object.prototype;
var po = fo ? Object.getPrototypeOf : function(t3) {
  return t3 = Kt(t3), S2(t3, so) ? t3[so] : "function" == typeof t3.constructor && t3 instanceof t3.constructor ? t3.constructor.prototype : t3 instanceof Object ? vo : null;
};
var go = ne("iterator");
var ho = false;
[].keys && ("next" in (Zr = [].keys()) ? (Jr = po(po(Zr))) !== Object.prototype && (Qr = Jr) : ho = true), (null == Qr || o2(function() {
  var t3 = {};
  return Qr[go].call(t3) !== t3;
})) && (Qr = {}), S2(Qr, go) || I2(Qr, go, function() {
  return this;
});
var yo = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho };
var mo = yo.IteratorPrototype;
var So = function() {
  return this;
};
var xo = yo.IteratorPrototype;
var bo = yo.BUGGY_SAFARI_ITERATORS;
var Eo = ne("iterator");
var wo = function() {
  return this;
};
var Oo = function(t3, e2, n3, r3, o3, i3, u3) {
  !function(t4, e3, n4) {
    var r4 = e3 + " Iterator";
    t4.prototype = Sr(mo, { next: l2(1, n4) }), ao(t4, r4, false), Pr[r4] = So;
  }(n3, e2, r3);
  var a3, c3, f3, s3 = function(t4) {
    if (t4 === o3 && h4) return h4;
    if (!bo && t4 in p3) return p3[t4];
    switch (t4) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n3(this, t4);
        };
    }
    return function() {
      return new n3(this);
    };
  }, d3 = e2 + " Iterator", v3 = false, p3 = t3.prototype, g3 = p3[Eo] || p3["@@iterator"] || o3 && p3[o3], h4 = !bo && g3 || s3(o3), y3 = "Array" == e2 && p3.entries || g3;
  if (y3 && (a3 = po(y3.call(new t3())), xo !== Object.prototype && a3.next && (po(a3) !== xo && (co ? co(a3, xo) : "function" != typeof a3[Eo] && I2(a3, Eo, wo)), ao(a3, d3, true))), "values" == o3 && g3 && "values" !== g3.name && (v3 = true, h4 = function() {
    return g3.call(this);
  }), p3[Eo] !== h4 && I2(p3, Eo, h4), Pr[e2] = h4, o3) if (c3 = { values: s3("values"), keys: i3 ? h4 : s3("keys"), entries: s3("entries") }, u3) for (f3 in c3) (bo || v3 || !(f3 in p3)) && Z(p3, f3, c3[f3]);
  else It({ target: e2, proto: true, forced: bo || v3 }, c3);
  return c3;
};
var To = ne("species");
var Ao = R2.f;
var ko = eo.fastKey;
var Ro = J2.set;
var Io = J2.getterFor;
!function(t3, e2, n3) {
  var i3 = -1 !== t3.indexOf("Map"), u3 = -1 !== t3.indexOf("Weak"), a3 = i3 ? "set" : "add", c3 = r2[t3], l3 = c3 && c3.prototype, f3 = c3, s3 = {}, d3 = function(t4) {
    var e3 = l3[t4];
    Z(l3, t4, "add" == t4 ? function(t5) {
      return e3.call(this, 0 === t5 ? 0 : t5), this;
    } : "delete" == t4 ? function(t5) {
      return !(u3 && !h3(t5)) && e3.call(this, 0 === t5 ? 0 : t5);
    } : "get" == t4 ? function(t5) {
      return u3 && !h3(t5) ? void 0 : e3.call(this, 0 === t5 ? 0 : t5);
    } : "has" == t4 ? function(t5) {
      return !(u3 && !h3(t5)) && e3.call(this, 0 === t5 ? 0 : t5);
    } : function(t5, n4) {
      return e3.call(this, 0 === t5 ? 0 : t5, n4), this;
    });
  };
  if (kt(t3, "function" != typeof c3 || !(u3 || l3.forEach && !o2(function() {
    new c3().entries().next();
  })))) f3 = n3.getConstructor(e2, t3, i3, a3), eo.REQUIRED = true;
  else if (kt(t3, true)) {
    var v3 = new f3(), p3 = v3[a3](u3 ? {} : -0, 1) != v3, g3 = o2(function() {
      v3.has(1);
    }), y3 = Br(function(t4) {
      new c3(t4);
    }), m3 = !u3 && o2(function() {
      for (var t4 = new c3(), e3 = 5; e3--; ) t4[a3](e3, e3);
      return !t4.has(-0);
    });
    y3 || ((f3 = e2(function(e3, n4) {
      oo(e3, f3, t3);
      var r3 = function(t4, e4, n5) {
        var r4, o3;
        return co && "function" == typeof (r4 = e4.constructor) && r4 !== n5 && h3(o3 = r4.prototype) && o3 !== n5.prototype && co(t4, o3), t4;
      }(new c3(), e3, f3);
      return null != n4 && ro(n4, r3[a3], { that: r3, AS_ENTRIES: i3 }), r3;
    })).prototype = l3, l3.constructor = f3), (g3 || m3) && (d3("delete"), d3("has"), i3 && d3("get")), (m3 || p3) && d3(a3), u3 && l3.clear && delete l3.clear;
  }
  s3[t3] = f3, It({ global: true, forced: f3 != c3 }, s3), ao(f3, t3), u3 || n3.setStrong(f3, t3, i3);
}("Set", function(t3) {
  return function() {
    return t3(this, arguments.length ? arguments[0] : void 0);
  };
}, { getConstructor: function(t3, e2, n3, r3) {
  var o3 = t3(function(t4, u4) {
    oo(t4, o3, e2), Ro(t4, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i2 || (t4.size = 0), null != u4 && ro(u4, t4[r3], { that: t4, AS_ENTRIES: n3 });
  }), u3 = Io(e2), a3 = function(t4, e3, n4) {
    var r4, o4, a4 = u3(t4), l3 = c3(t4, e3);
    return l3 ? l3.value = n4 : (a4.last = l3 = { index: o4 = ko(e3, true), key: e3, value: n4, previous: r4 = a4.last, next: void 0, removed: false }, a4.first || (a4.first = l3), r4 && (r4.next = l3), i2 ? a4.size++ : t4.size++, "F" !== o4 && (a4.index[o4] = l3)), t4;
  }, c3 = function(t4, e3) {
    var n4, r4 = u3(t4), o4 = ko(e3);
    if ("F" !== o4) return r4.index[o4];
    for (n4 = r4.first; n4; n4 = n4.next) if (n4.key == e3) return n4;
  };
  return lo(o3.prototype, { clear: function() {
    for (var t4 = u3(this), e3 = t4.index, n4 = t4.first; n4; ) n4.removed = true, n4.previous && (n4.previous = n4.previous.next = void 0), delete e3[n4.index], n4 = n4.next;
    t4.first = t4.last = void 0, i2 ? t4.size = 0 : this.size = 0;
  }, delete: function(t4) {
    var e3 = this, n4 = u3(e3), r4 = c3(e3, t4);
    if (r4) {
      var o4 = r4.next, a4 = r4.previous;
      delete n4.index[r4.index], r4.removed = true, a4 && (a4.next = o4), o4 && (o4.previous = a4), n4.first == r4 && (n4.first = o4), n4.last == r4 && (n4.last = a4), i2 ? n4.size-- : e3.size--;
    }
    return !!r4;
  }, forEach: function(t4) {
    for (var e3, n4 = u3(this), r4 = lr(t4, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n4.first; ) for (r4(e3.value, e3.key, this); e3 && e3.removed; ) e3 = e3.previous;
  }, has: function(t4) {
    return !!c3(this, t4);
  } }), lo(o3.prototype, n3 ? { get: function(t4) {
    var e3 = c3(this, t4);
    return e3 && e3.value;
  }, set: function(t4, e3) {
    return a3(this, 0 === t4 ? 0 : t4, e3);
  } } : { add: function(t4) {
    return a3(this, t4 = 0 === t4 ? 0 : t4, t4);
  } }), i2 && Ao(o3.prototype, "size", { get: function() {
    return u3(this).size;
  } }), o3;
}, setStrong: function(t3, e2, n3) {
  var r3 = e2 + " Iterator", o3 = Io(e2), u3 = Io(r3);
  Oo(t3, e2, function(t4, e3) {
    Ro(this, { type: r3, target: t4, state: o3(t4), kind: e3, last: void 0 });
  }, function() {
    for (var t4 = u3(this), e3 = t4.kind, n4 = t4.last; n4 && n4.removed; ) n4 = n4.previous;
    return t4.target && (t4.last = n4 = n4 ? n4.next : t4.state.first) ? "keys" == e3 ? { value: n4.key, done: false } : "values" == e3 ? { value: n4.value, done: false } : { value: [n4.key, n4.value], done: false } : (t4.target = void 0, { value: void 0, done: true });
  }, n3 ? "entries" : "values", !n3, true), function(t4) {
    var e3 = nt(t4), n4 = R2.f;
    i2 && e3 && !e3[To] && n4(e3, To, { configurable: true, get: function() {
      return this;
    } });
  }(e2);
} });
var jo = Qe.charAt;
var Co = J2.set;
var Lo = J2.getterFor("String Iterator");
Oo(String, "String", function(t3) {
  Co(this, { type: "String Iterator", string: String(t3), index: 0 });
}, function() {
  var t3, e2 = Lo(this), n3 = e2.string, r3 = e2.index;
  return r3 >= n3.length ? { value: void 0, done: true } : (t3 = jo(n3, r3), e2.index += t3.length, { value: t3, done: false });
});
var Po = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
var Mo = J2.set;
var _o = J2.getterFor("Array Iterator");
var Do = Oo(Array, "Array", function(t3, e2) {
  Mo(this, { type: "Array Iterator", target: g2(t3), index: 0, kind: e2 });
}, function() {
  var t3 = _o(this), e2 = t3.target, n3 = t3.kind, r3 = t3.index++;
  return !e2 || r3 >= e2.length ? (t3.target = void 0, { value: void 0, done: true }) : "keys" == n3 ? { value: r3, done: false } : "values" == n3 ? { value: e2[r3], done: false } : { value: [r3, e2[r3]], done: false };
}, "values");
Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
var Uo = ne("iterator");
var No = ne("toStringTag");
var Fo = Do.values;
for (Wo2 in Po) {
  zo2 = r2[Wo2], $o2 = zo2 && zo2.prototype;
  if ($o2) {
    if ($o2[Uo] !== Fo) try {
      I2($o2, Uo, Fo);
    } catch (t3) {
      $o2[Uo] = Fo;
    }
    if ($o2[No] || I2($o2, No, Wo2), Po[Wo2]) {
      for (Bo2 in Do) if ($o2[Bo2] !== Do[Bo2]) try {
        I2($o2, Bo2, Do[Bo2]);
      } catch (t3) {
        $o2[Bo2] = Do[Bo2];
      }
    }
  }
}
var zo2;
var $o2;
var Bo2;
var Wo2;
var Yo = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "deduplicate", value: function(t4) {
    return Array.from(new Set(t4));
  } }, { key: "flat", value: function(e2) {
    return e2.reduce(function(e3, n3) {
      var r3 = Array.isArray(n3) ? t3.flat(n3) : n3;
      return e3.concat(r3);
    }, []);
  } }, { key: "find", value: function(t4, e2) {
    return t4.find(e2);
  } }, { key: "findIndex", value: function(t4, e2) {
    return t4.findIndex(e2);
  } }]), t3;
}();
var Go = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "today", value: function() {
    return /* @__PURE__ */ new Date();
  } }]), t3;
}();
var Vo = function() {
  function t3() {
    Wt(this, t3);
  }
  return $t(t3, null, [{ key: "range", value: function(t4, e2, n3) {
    return Math.min(Math.max(t4, e2), n3);
  } }, { key: "clamp", value: function(t4, e2, n3) {
    return e2 < n3 ? t4 < e2 ? e2 : t4 > n3 ? n3 : t4 : t4 < n3 ? n3 : t4 > e2 ? e2 : t4;
  } }]), t3;
}();

// node_modules/vue3-colorpicker/index.es.js
var qe2 = Object.defineProperty;
var Ye2 = (e2, t3, o3) => t3 in e2 ? qe2(e2, t3, { enumerable: true, configurable: true, writable: true, value: o3 }) : e2[t3] = o3;
var W2 = (e2, t3, o3) => (Ye2(e2, typeof t3 != "symbol" ? t3 + "" : t3, o3), o3);
var P3 = (e2) => Math.round(e2 * 100) / 100;
var A3 = class {
  constructor(t3) {
    W2(this, "instance");
    W2(this, "alphaValue", 0);
    W2(this, "redValue", 0);
    W2(this, "greenValue", 0);
    W2(this, "blueValue", 0);
    W2(this, "hueValue", 0);
    W2(this, "saturationValue", 0);
    W2(this, "brightnessValue", 0);
    W2(this, "hslSaturationValue", 0);
    W2(this, "lightnessValue", 0);
    W2(this, "initAlpha", () => {
      const t4 = this.instance.getAlpha();
      this.alphaValue = Math.min(1, t4) * 100;
    });
    W2(this, "initLightness", () => {
      const { s: t4, l: o3 } = this.instance.toHsl();
      this.hslSaturationValue = P3(t4), this.lightnessValue = P3(o3);
    });
    W2(this, "initRgb", () => {
      const { r: t4, g: o3, b: n3 } = this.instance.toRgb();
      this.redValue = P3(t4), this.greenValue = P3(o3), this.blueValue = P3(n3);
    });
    W2(this, "initHsb", () => {
      const { h: t4, s: o3, v: n3 } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(t4)), this.saturationValue = P3(o3), this.brightnessValue = P3(n3);
    });
    W2(this, "toHexString", () => this.instance.toHexString());
    W2(this, "toRgbString", () => this.instance.toRgbString());
    this.instance = tinycolor(t3), this.initRgb(), this.initHsb(), this.initLightness(), this.initAlpha();
  }
  toString(t3) {
    return this.instance.toString(t3);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(t3) {
    this.instance = tinycolor(t3), this.initHsb(), this.initRgb(), this.initAlpha(), this.initLightness();
  }
  // 色调
  set hue(t3) {
    this.saturation === 0 && this.brightness === 0 && (this.saturationValue = 1, this.brightnessValue = 1), this.instance = tinycolor({
      h: P3(t3),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.hueValue = P3(t3);
  }
  get hue() {
    return this.hueValue;
  }
  // 饱和度
  set saturation(t3) {
    this.instance = tinycolor({
      h: this.hue,
      s: P3(t3),
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.saturationValue = P3(t3);
  }
  get saturation() {
    return this.saturationValue;
  }
  // 明度
  set brightness(t3) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.saturation,
      v: P3(t3),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.brightnessValue = P3(t3);
  }
  get brightness() {
    return this.brightnessValue;
  }
  // 亮度
  set lightness(t3) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.hslSaturationValue,
      l: P3(t3),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initHsb(), this.lightnessValue = P3(t3);
  }
  get lightness() {
    return this.lightnessValue;
  }
  // red
  set red(t3) {
    const o3 = this.instance.toRgb();
    this.instance = tinycolor({
      ...o3,
      r: P3(t3),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.redValue = P3(t3);
  }
  get red() {
    return this.redValue;
  }
  // green
  set green(t3) {
    const o3 = this.instance.toRgb();
    this.instance = tinycolor({
      ...o3,
      g: P3(t3),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.greenValue = P3(t3);
  }
  get green() {
    return this.greenValue;
  }
  // blue
  set blue(t3) {
    const o3 = this.instance.toRgb();
    this.instance = tinycolor({
      ...o3,
      b: P3(t3),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.blueValue = P3(t3);
  }
  get blue() {
    return this.blueValue;
  }
  // alpha
  set alpha(t3) {
    this.instance.setAlpha(t3 / 100), this.alphaValue = t3;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, parseFloat((this.alpha / 100).toFixed(2))];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, parseFloat((this.alpha / 100).toFixed(2))];
  }
  get HSL() {
    return [
      this.hue,
      this.hslSaturationValue,
      this.lightness,
      parseFloat((this.alpha / 100).toFixed(2))
    ];
  }
};
function Ae2(e2, t3, o3, n3) {
  return `rgba(${[e2, t3, o3, n3 / 100].join(",")})`;
}
var ue2 = (e2, t3, o3) => t3 < o3 ? e2 < t3 ? t3 : e2 > o3 ? o3 : e2 : e2 < o3 ? o3 : e2 > t3 ? t3 : e2;
var fe2 = "color-history";
var Ce2 = 8;
var q2 = (e2, t3) => {
  const o3 = e2.__vccOpts || e2;
  for (const [n3, i3] of t3)
    o3[n3] = i3;
  return o3;
};
var lt2 = defineComponent({
  name: "Alpha",
  props: {
    color: C.instanceOf(A3),
    size: C.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(e2, { emit: t3 }) {
    const o3 = ref(null), n3 = ref(null);
    let i3 = e2.color || new A3();
    const l3 = reactive({
      red: i3.red,
      green: i3.green,
      blue: i3.blue,
      alpha: i3.alpha
    });
    watch(
      () => e2.color,
      (g3) => {
        g3 && (i3 = g3, merge_default(l3, {
          red: g3.red,
          green: g3.green,
          blue: g3.blue,
          alpha: g3.alpha
        }));
      },
      { deep: true }
    );
    const a3 = computed(() => {
      const g3 = Ae2(l3.red, l3.green, l3.blue, 0), d3 = Ae2(l3.red, l3.green, l3.blue, 100);
      return {
        background: `linear-gradient(to right, ${g3} , ${d3})`
      };
    }), r3 = () => {
      if (o3.value && n3.value) {
        const g3 = l3.alpha / 100, d3 = o3.value.getBoundingClientRect(), m3 = n3.value.offsetWidth;
        return Math.round(g3 * (d3.width - m3) + m3 / 2);
      }
      return 0;
    }, c3 = computed(() => ({
      left: r3() + "px",
      top: 0
    })), k2 = (g3) => {
      g3.target !== o3.value && p3(g3);
    }, p3 = (g3) => {
      if (g3.stopPropagation(), o3.value && n3.value) {
        const d3 = o3.value.getBoundingClientRect(), m3 = n3.value.offsetWidth;
        let b3 = g3.clientX - d3.left;
        b3 = Math.max(m3 / 2, b3), b3 = Math.min(b3, d3.width - m3 / 2);
        const h4 = Math.round((b3 - m3 / 2) / (d3.width - m3) * 100);
        i3.alpha = h4, l3.alpha = h4, t3("change", h4);
      }
    };
    return tryOnMounted(() => {
      const g3 = {
        drag: (d3) => {
          p3(d3);
        },
        end: (d3) => {
          p3(d3);
        }
      };
      o3.value && n3.value && Vn.triggerDragEvent(o3.value, g3);
    }), { barElement: o3, cursorElement: n3, getCursorStyle: c3, getBackgroundStyle: a3, onClickSider: k2 };
  }
});
var st2 = (e2) => (pushScopeId("data-v-18925ba6"), e2 = e2(), popScopeId(), e2);
var it2 = st2(() => createBaseVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
var ct2 = [
  it2
];
function ut2(e2, t3, o3, n3, i3, l3) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": e2.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle(e2.getBackgroundStyle),
      onClick: t3[0] || (t3[0] = (...a3) => e2.onClickSider && e2.onClickSider(...a3))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(e2.getCursorStyle)
      }, ct2, 6)
    ], 4)
  ], 2);
}
var ve2 = q2(lt2, [["render", ut2], ["__scopeId", "data-v-18925ba6"]]);
var dt2 = [
  // 第一行
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  // 第二行
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  // 第三行
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  // 第四行
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  // 第五行
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  // 最后一行
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
];
var gt2 = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(e2, { emit: t3 }) {
    return { palettes: dt2, computedBgStyle: (i3) => i3 === "transparent" ? i3 : i3 === "advance" ? {} : { background: tinycolor(i3).toRgbString() }, onColorChange: (i3) => {
      t3("change", i3);
    } };
  }
});
var ht2 = { class: "vc-compact" };
var pt2 = ["onClick"];
function ft2(e2, t3, o3, n3, i3, l3) {
  return openBlock(), createElementBlock("div", ht2, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(e2.palettes, (a3, r3) => (openBlock(), createElementBlock("div", {
      key: r3,
      class: "vc-compact__row"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(a3, (c3, k2) => (openBlock(), createElementBlock("div", {
        key: k2,
        class: "vc-compact__color-cube--wrap",
        onClick: (p3) => e2.onColorChange(c3)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            "vc-compact__color_cube",
            {
              advance: c3 === "advance",
              transparent: c3 === "transparent"
            }
          ]),
          style: normalizeStyle(e2.computedBgStyle(c3))
        }, null, 6)
      ], 8, pt2))), 128))
    ]))), 128))
  ]);
}
var Ke2 = q2(gt2, [["render", ft2], ["__scopeId", "data-v-b969fd48"]]);
var Ct2 = defineComponent({
  name: "Board",
  props: {
    color: C.instanceOf(A3),
    round: C.bool.def(false),
    hide: C.bool.def(true)
  },
  emits: ["change"],
  setup(e2, { emit: t3 }) {
    var y3, f3, w3;
    const o3 = getCurrentInstance(), n3 = {
      h: ((y3 = e2.color) == null ? void 0 : y3.hue) || 0,
      s: 1,
      v: 1
    }, i3 = new A3(n3).toHexString(), l3 = reactive({
      hueColor: i3,
      saturation: ((f3 = e2.color) == null ? void 0 : f3.saturation) || 0,
      brightness: ((w3 = e2.color) == null ? void 0 : w3.brightness) || 0
    }), a3 = ref(0), r3 = ref(0), c3 = ref(), k2 = computed(() => ({
      top: a3.value + "px",
      left: r3.value + "px"
    })), p3 = () => {
      if (o3) {
        const S3 = o3.vnode.el;
        r3.value = l3.saturation * (S3 == null ? void 0 : S3.clientWidth), a3.value = (1 - l3.brightness) * (S3 == null ? void 0 : S3.clientHeight);
      }
    };
    let g3 = false;
    const d3 = (S3) => {
      g3 = true, h4(S3);
    }, m3 = (S3) => {
      g3 && h4(S3);
    }, b3 = () => {
      g3 = false;
    }, h4 = (S3) => {
      if (o3) {
        const F3 = o3.vnode.el, E3 = F3 == null ? void 0 : F3.getBoundingClientRect();
        let L3 = S3.clientX - E3.left, U2 = S3.clientY - E3.top;
        L3 = ue2(L3, 0, E3.width), U2 = ue2(U2, 0, E3.height);
        const J3 = L3 / E3.width, X = ue2(-(U2 / E3.height) + 1, 0, 1);
        r3.value = L3, a3.value = U2, l3.saturation = J3, l3.brightness = X, t3("change", J3, X);
      }
    };
    return tryOnMounted(() => {
      o3 && o3.vnode.el && c3.value && nextTick(() => {
        p3();
      });
    }), whenever(
      () => e2.color,
      (S3) => {
        merge_default(l3, {
          hueColor: new A3({ h: S3.hue, s: 1, v: 1 }).toHexString(),
          saturation: S3.saturation,
          brightness: S3.brightness
        }), p3();
      },
      { deep: true }
    ), { state: l3, cursorElement: c3, getCursorStyle: k2, onClickBoard: d3, onDrag: m3, onDragEnd: b3 };
  }
});
var be2 = (e2) => (pushScopeId("data-v-7f0cdcdf"), e2 = e2(), popScopeId(), e2);
var vt2 = be2(() => createBaseVNode("div", { class: "vc-saturation__white" }, null, -1));
var bt2 = be2(() => createBaseVNode("div", { class: "vc-saturation__black" }, null, -1));
var yt2 = be2(() => createBaseVNode("div", null, null, -1));
var _t2 = [
  yt2
];
function mt2(e2, t3, o3, n3, i3, l3) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": e2.round, "vc-saturation__hidden": e2.hide }]),
    style: normalizeStyle({ backgroundColor: e2.state.hueColor }),
    onMousedown: t3[0] || (t3[0] = (...a3) => e2.onClickBoard && e2.onClickBoard(...a3)),
    onMousemove: t3[1] || (t3[1] = (...a3) => e2.onDrag && e2.onDrag(...a3)),
    onMouseup: t3[2] || (t3[2] = (...a3) => e2.onDragEnd && e2.onDragEnd(...a3))
  }, [
    vt2,
    bt2,
    createBaseVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle(e2.getCursorStyle)
    }, _t2, 4)
  ], 38);
}
var ye2 = q2(Ct2, [["render", mt2], ["__scopeId", "data-v-7f0cdcdf"]]);
var St2 = defineComponent({
  name: "Hue",
  props: {
    color: C.instanceOf(A3),
    size: C.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(e2, { emit: t3 }) {
    const o3 = ref(null), n3 = ref(null);
    let i3 = e2.color || new A3();
    const l3 = reactive({
      hue: i3.hue || 0
    });
    watch(
      () => e2.color,
      (p3) => {
        p3 && (i3 = p3, merge_default(l3, { hue: i3.hue }));
      },
      { deep: true }
    );
    const a3 = () => {
      if (o3.value && n3.value) {
        const p3 = o3.value.getBoundingClientRect(), g3 = n3.value.offsetWidth;
        return l3.hue === 360 ? p3.width - g3 / 2 : l3.hue % 360 * (p3.width - g3) / 360 + g3 / 2;
      }
      return 0;
    }, r3 = computed(() => ({
      left: a3() + "px",
      top: 0
    })), c3 = (p3) => {
      p3.target !== o3.value && k2(p3);
    }, k2 = (p3) => {
      if (p3.stopPropagation(), o3.value && n3.value) {
        const g3 = o3.value.getBoundingClientRect(), d3 = n3.value.offsetWidth;
        let m3 = p3.clientX - g3.left;
        m3 = Math.min(m3, g3.width - d3 / 2), m3 = Math.max(d3 / 2, m3);
        const b3 = Math.round((m3 - d3 / 2) / (g3.width - d3) * 360);
        i3.hue = b3, l3.hue = b3, t3("change", b3);
      }
    };
    return tryOnMounted(() => {
      const p3 = {
        drag: (g3) => {
          k2(g3);
        },
        end: (g3) => {
          k2(g3);
        }
      };
      o3.value && n3.value && Vn.triggerDragEvent(o3.value, p3);
    }), { barElement: o3, cursorElement: n3, getCursorStyle: r3, onClickSider: c3 };
  }
});
var kt2 = (e2) => (pushScopeId("data-v-e1a08576"), e2 = e2(), popScopeId(), e2);
var $t2 = kt2(() => createBaseVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
var wt2 = [
  $t2
];
function Bt2(e2, t3, o3, n3, i3, l3) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": e2.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: t3[0] || (t3[0] = (...a3) => e2.onClickSider && e2.onClickSider(...a3))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(e2.getCursorStyle)
      }, wt2, 6)
    ], 512)
  ], 2);
}
var _e2 = q2(St2, [["render", Bt2], ["__scopeId", "data-v-e1a08576"]]);
var Ht2 = defineComponent({
  name: "Lightness",
  props: {
    color: C.instanceOf(A3),
    size: C.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(e2, { emit: t3 }) {
    const o3 = ref(null), n3 = ref(null);
    let i3 = e2.color || new A3();
    const [l3, a3, r3] = i3.HSL, c3 = reactive({
      hue: l3,
      saturation: a3,
      lightness: r3
    });
    watch(
      () => e2.color,
      (b3) => {
        if (b3) {
          i3 = b3;
          const [h4, y3, f3] = i3.HSL;
          merge_default(c3, {
            hue: h4,
            saturation: y3,
            lightness: f3
          });
        }
      },
      { deep: true }
    );
    const k2 = computed(() => {
      const b3 = tinycolor({
        h: c3.hue,
        s: c3.saturation,
        l: 0.8
      }).toPercentageRgbString(), h4 = tinycolor({
        h: c3.hue,
        s: c3.saturation,
        l: 0.6
      }).toPercentageRgbString(), y3 = tinycolor({
        h: c3.hue,
        s: c3.saturation,
        l: 0.4
      }).toPercentageRgbString(), f3 = tinycolor({
        h: c3.hue,
        s: c3.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `linear-gradient(to right, rgb(255, 255, 255), ${b3}, ${h4}, ${y3}, ${f3}, rgb(0, 0, 0))`,
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${b3}, ${h4}, ${y3}, ${f3}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${b3}, ${h4}, ${y3}, ${f3}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${b3}, ${h4}, ${y3}, ${f3}, rgb(0, 0, 0))`
        ]
      };
    }), p3 = () => {
      if (o3.value && n3.value) {
        const b3 = c3.lightness, h4 = o3.value.getBoundingClientRect(), y3 = n3.value.offsetWidth;
        return (1 - b3) * (h4.width - y3) + y3 / 2;
      }
      return 0;
    }, g3 = computed(() => ({
      left: p3() + "px",
      top: 0
    })), d3 = (b3) => {
      b3.target !== o3.value && m3(b3);
    }, m3 = (b3) => {
      if (b3.stopPropagation(), o3.value && n3.value) {
        const h4 = o3.value.getBoundingClientRect(), y3 = n3.value.offsetWidth;
        let f3 = b3.clientX - h4.left;
        f3 = Math.max(y3 / 2, f3), f3 = Math.min(f3, h4.width - y3 / 2);
        const w3 = 1 - (f3 - y3 / 2) / (h4.width - y3);
        i3.lightness = w3, t3("change", w3);
      }
    };
    return tryOnMounted(() => {
      const b3 = {
        drag: (h4) => {
          m3(h4);
        },
        end: (h4) => {
          m3(h4);
        }
      };
      o3.value && n3.value && Vn.triggerDragEvent(o3.value, b3);
    }), { barElement: o3, cursorElement: n3, getCursorStyle: g3, getBackgroundStyle: k2, onClickSider: d3 };
  }
});
var Rt2 = (e2) => (pushScopeId("data-v-94a50a9e"), e2 = e2(), popScopeId(), e2);
var At2 = Rt2(() => createBaseVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
var Pt2 = [
  At2
];
function Vt2(e2, t3, o3, n3, i3, l3) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": e2.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle(e2.getBackgroundStyle),
      onClick: t3[0] || (t3[0] = (...a3) => e2.onClickSider && e2.onClickSider(...a3))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(e2.getCursorStyle)
      }, Pt2, 6)
    ], 4)
  ], 2);
}
var Le2 = q2(Ht2, [["render", Vt2], ["__scopeId", "data-v-94a50a9e"]]);
var Mt2 = defineComponent({
  name: "History",
  props: {
    colors: C.arrayOf(String).def(() => []),
    round: C.bool.def(false)
  },
  emits: ["change"],
  setup(e2, { emit: t3 }) {
    return { onColorSelect: (n3) => {
      t3("change", n3);
    } };
  }
});
var Et2 = {
  key: 0,
  class: "vc-colorPicker__record"
};
var It2 = { class: "color-list" };
var Kt2 = ["onClick"];
function Lt2(e2, t3, o3, n3, i3, l3) {
  return e2.colors && e2.colors.length > 0 ? (openBlock(), createElementBlock("div", Et2, [
    createBaseVNode("div", It2, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e2.colors, (a3, r3) => (openBlock(), createElementBlock("div", {
        key: r3,
        class: normalizeClass(["color-item", "transparent", { "color-item__round": e2.round }]),
        onClick: (c3) => e2.onColorSelect(a3)
      }, [
        createBaseVNode("div", {
          class: "color-item__display",
          style: normalizeStyle({ backgroundColor: a3 })
        }, null, 4)
      ], 10, Kt2))), 128))
    ])
  ])) : createCommentVNode("", true);
}
var me2 = q2(Mt2, [["render", Lt2], ["__scopeId", "data-v-0f657238"]]);
var Nt2 = defineComponent({
  name: "Display",
  props: {
    color: C.instanceOf(A3),
    disableAlpha: C.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(e2, { emit: t3 }) {
    var m3, b3, h4, y3;
    const { copy: o3, copied: n3, isSupported: i3 } = useClipboard(), l3 = ref("hex"), a3 = reactive({
      color: e2.color,
      hex: (m3 = e2.color) == null ? void 0 : m3.hex,
      alpha: Math.round(((b3 = e2.color) == null ? void 0 : b3.alpha) || 100),
      rgba: (h4 = e2.color) == null ? void 0 : h4.RGB,
      previewBgColor: (y3 = e2.color) == null ? void 0 : y3.toRgbString()
    }), r3 = computed(() => ({
      background: a3.previewBgColor
    })), c3 = () => {
      l3.value = l3.value === "rgba" ? "hex" : "rgba";
    }, k2 = useDebounceFn((f3) => {
      if (!f3.target.value)
        return;
      let w3 = parseInt(f3.target.value.replace("%", ""));
      w3 > 100 && (f3.target.value = "100", w3 = 100), w3 < 0 && (f3.target.value = "0", w3 = 0), isNaN(w3) && (f3.target.value = "100", w3 = 100), !isNaN(w3) && a3.color && (a3.color.alpha = w3), t3("change", a3.color);
    }, 300), p3 = useDebounceFn((f3, w3) => {
      if (a3.color) {
        if (l3.value === "hex") {
          const S3 = f3.target.value.replace("#", "");
          tinycolor(S3).isValid() ? [3, 4].includes(S3.length) && (a3.color.hex = S3) : a3.color.hex = "000000", t3("change", a3.color);
        } else if (l3.value === "rgba" && w3 === 3 && f3.target.value.toString() === "0." && a3.rgba) {
          a3.rgba[w3] = f3.target.value;
          const [S3, F3, E3, L3] = a3.rgba;
          a3.color.hex = tinycolor({ r: S3, g: F3, b: E3 }).toHex(), a3.color.alpha = Math.round(L3 * 100), t3("change", a3.color);
        }
      }
    }, 100), g3 = useDebounceFn((f3, w3) => {
      if (f3.target.value) {
        if (l3.value === "hex") {
          const S3 = f3.target.value.replace("#", "");
          tinycolor(S3).isValid() && a3.color && [6, 8].includes(S3.length) && (a3.color.hex = S3);
        } else if (w3 !== void 0 && a3.rgba && a3.color) {
          if (f3.target.value < 0 && (f3.target.value = 0), w3 === 3 && ((f3.target.value > 1 || isNaN(f3.target.value)) && (f3.target.value = 1), f3.target.value.toString() === "0."))
            return;
          w3 < 3 && f3.target.value > 255 && (f3.target.value = 255), a3.rgba[w3] = f3.target.value;
          const [S3, F3, E3, L3] = a3.rgba;
          a3.color.hex = tinycolor({ r: S3, g: F3, b: E3 }).toHex(), a3.color.alpha = Math.round(L3 * 100);
        }
        t3("change", a3.color);
      }
    }, 300), d3 = () => {
      if (i3 && a3.color) {
        const f3 = l3.value === "hex" ? a3.color.toString(a3.color.alpha === 100 ? "hex6" : "hex8") : a3.color.toRgbString();
        o3(f3 || "");
      }
    };
    return whenever(
      () => e2.color,
      (f3) => {
        f3 && (a3.color = f3, a3.alpha = Math.round(a3.color.alpha), a3.hex = a3.color.hex, a3.rgba = a3.color.RGB);
      },
      { deep: true }
    ), whenever(
      () => a3.color,
      () => {
        a3.color && (a3.previewBgColor = a3.color.toRgbString());
      },
      { deep: true }
    ), {
      state: a3,
      getBgColorStyle: r3,
      inputType: l3,
      copied: n3,
      onInputTypeChange: c3,
      onAlphaBlur: k2,
      onInputChange: g3,
      onBlurChange: p3,
      onCopyColorStr: d3
    };
  }
});
var Wt2 = { class: "vc-display" };
var Dt2 = { class: "vc-current-color vc-transparent" };
var Tt2 = {
  key: 0,
  class: "copy-text"
};
var Ot2 = {
  key: 0,
  style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
};
var zt2 = { class: "vc-color-input" };
var Gt2 = {
  key: 0,
  class: "vc-alpha-input"
};
var Ft2 = ["value"];
var Xt2 = {
  key: 1,
  style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
};
var qt2 = ["value", "onInput", "onBlur"];
function Yt2(e2, t3, o3, n3, i3, l3) {
  return openBlock(), createElementBlock("div", Wt2, [
    createBaseVNode("div", Dt2, [
      createBaseVNode("div", {
        class: "color-cube",
        style: normalizeStyle(e2.getBgColorStyle),
        onClick: t3[0] || (t3[0] = (...a3) => e2.onCopyColorStr && e2.onCopyColorStr(...a3))
      }, [
        e2.copied ? (openBlock(), createElementBlock("span", Tt2, "Copied!")) : createCommentVNode("", true)
      ], 4)
    ]),
    e2.inputType === "hex" ? (openBlock(), createElementBlock("div", Ot2, [
      createBaseVNode("div", zt2, [
        withDirectives(createBaseVNode("input", {
          "onUpdate:modelValue": t3[1] || (t3[1] = (a3) => e2.state.hex = a3),
          maxlength: "8",
          onInput: t3[2] || (t3[2] = (...a3) => e2.onInputChange && e2.onInputChange(...a3)),
          onBlur: t3[3] || (t3[3] = (...a3) => e2.onBlurChange && e2.onBlurChange(...a3))
        }, null, 544), [
          [vModelText, e2.state.hex]
        ])
      ]),
      e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Gt2, [
        createBaseVNode("input", {
          class: "vc-alpha-input__inner",
          value: e2.state.alpha,
          onInput: t3[4] || (t3[4] = (...a3) => e2.onAlphaBlur && e2.onAlphaBlur(...a3))
        }, null, 40, Ft2),
        createTextVNode("% ")
      ]))
    ])) : e2.state.rgba ? (openBlock(), createElementBlock("div", Xt2, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e2.state.rgba, (a3, r3) => (openBlock(), createElementBlock("div", {
        class: "vc-color-input",
        key: r3
      }, [
        createBaseVNode("input", {
          value: a3,
          onInput: (c3) => e2.onInputChange(c3, r3),
          onBlur: (c3) => e2.onBlurChange(c3, r3)
        }, null, 40, qt2)
      ]))), 128))
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: "vc-input-toggle",
      onClick: t3[5] || (t3[5] = (...a3) => e2.onInputTypeChange && e2.onInputTypeChange(...a3))
    }, toDisplayString(e2.inputType), 1)
  ]);
}
var Se2 = q2(Nt2, [["render", Yt2], ["__scopeId", "data-v-7334ac20"]]);
var Ut2 = defineComponent({
  name: "FkColorPicker",
  components: { Display: Se2, Alpha: ve2, Palette: Ke2, Board: ye2, Hue: _e2, Lightness: Le2, History: me2 },
  props: {
    color: C.instanceOf(A3),
    disableHistory: C.bool.def(false),
    roundHistory: C.bool.def(false),
    disableAlpha: C.bool.def(false)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(e2, { emit: t3 }) {
    const o3 = e2.color || new A3(), n3 = reactive({
      color: o3,
      hex: o3.toHexString(),
      rgb: o3.toRgbString()
    }), i3 = ref(false), l3 = computed(() => ({ background: n3.rgb })), a3 = () => {
      i3.value = false, t3("advanceChange", false);
    }, r3 = useLocalStorage(fe2, [], {}), c3 = useDebounceFn(() => {
      if (e2.disableHistory)
        return;
      const h4 = n3.color.toRgbString();
      if (r3.value = r3.value.filter((y3) => !tinycolor.equals(y3, h4)), !r3.value.includes(h4)) {
        for (; r3.value.length > Ce2; )
          r3.value.pop();
        r3.value.unshift(h4);
      }
    }, 500), k2 = (h4) => {
      h4 === "advance" ? (i3.value = true, t3("advanceChange", true)) : (n3.color.hex = h4, t3("advanceChange", false));
    }, p3 = (h4) => {
      n3.color.alpha = h4;
    }, g3 = (h4) => {
      n3.color.hue = h4;
    }, d3 = (h4, y3) => {
      n3.color.saturation = h4, n3.color.brightness = y3;
    }, m3 = (h4) => {
      n3.color.lightness = h4;
    }, b3 = (h4) => {
      const f3 = h4.target.value.replace("#", "");
      tinycolor(f3).isValid() && (n3.color.hex = f3);
    };
    return whenever(
      () => e2.color,
      (h4) => {
        h4 && (n3.color = h4);
      },
      { deep: true }
    ), whenever(
      () => n3.color,
      () => {
        n3.hex = n3.color.hex, n3.rgb = n3.color.toRgbString(), c3(), t3("update:color", n3.color), t3("change", n3.color);
      },
      { deep: true }
    ), {
      state: n3,
      advancePanelShow: i3,
      onBack: a3,
      onCompactChange: k2,
      onAlphaChange: p3,
      onHueChange: g3,
      onBoardChange: d3,
      onLightChange: m3,
      onInputChange: b3,
      previewStyle: l3,
      historyColors: r3
    };
  }
});
var jt2 = (e2) => (pushScopeId("data-v-48e3c224"), e2 = e2(), popScopeId(), e2);
var Zt2 = { class: "vc-fk-colorPicker" };
var Jt2 = { class: "vc-fk-colorPicker__inner" };
var Qt2 = { class: "vc-fk-colorPicker__header" };
var xt2 = jt2(() => createBaseVNode("div", { class: "back" }, null, -1));
var eo2 = [
  xt2
];
function to2(e2, t3, o3, n3, i3, l3) {
  const a3 = resolveComponent("Palette"), r3 = resolveComponent("Board"), c3 = resolveComponent("Hue"), k2 = resolveComponent("Lightness"), p3 = resolveComponent("Alpha"), g3 = resolveComponent("Display"), d3 = resolveComponent("History");
  return openBlock(), createElementBlock("div", Zt2, [
    createBaseVNode("div", Jt2, [
      createBaseVNode("div", Qt2, [
        e2.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { cursor: "pointer" },
          onClick: t3[0] || (t3[0] = (...m3) => e2.onBack && e2.onBack(...m3))
        }, eo2)) : createCommentVNode("", true)
      ]),
      e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(a3, {
        key: 0,
        onChange: e2.onCompactChange
      }, null, 8, ["onChange"])),
      e2.advancePanelShow ? (openBlock(), createBlock(r3, {
        key: 1,
        color: e2.state.color,
        onChange: e2.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      e2.advancePanelShow ? (openBlock(), createBlock(c3, {
        key: 2,
        color: e2.state.color,
        onChange: e2.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(k2, {
        key: 3,
        color: e2.state.color,
        onChange: e2.onLightChange
      }, null, 8, ["color", "onChange"])),
      e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(p3, {
        key: 4,
        color: e2.state.color,
        onChange: e2.onAlphaChange
      }, null, 8, ["color", "onChange"])),
      createVNode(g3, {
        color: e2.state.color,
        "disable-alpha": e2.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(d3, {
        key: 5,
        round: e2.roundHistory,
        colors: e2.historyColors,
        onChange: e2.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
var Pe2 = q2(Ut2, [["render", to2], ["__scopeId", "data-v-48e3c224"]]);
var oo2 = defineComponent({
  name: "ChromeColorPicker",
  components: { Display: Se2, Alpha: ve2, Board: ye2, Hue: _e2, History: me2 },
  props: {
    color: C.instanceOf(A3),
    disableHistory: C.bool.def(false),
    roundHistory: C.bool.def(false),
    disableAlpha: C.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(e2, { emit: t3 }) {
    const o3 = e2.color || new A3(), n3 = reactive({
      color: o3,
      hex: o3.toHexString(),
      rgb: o3.toRgbString()
    }), i3 = computed(() => ({ background: n3.rgb })), l3 = useLocalStorage(fe2, [], {}), a3 = useDebounceFn(() => {
      if (e2.disableHistory)
        return;
      const d3 = n3.color.toRgbString();
      if (l3.value = l3.value.filter((m3) => !tinycolor.equals(m3, d3)), !l3.value.includes(d3)) {
        for (; l3.value.length > Ce2; )
          l3.value.pop();
        l3.value.unshift(d3);
      }
    }, 500), r3 = (d3) => {
      n3.color.alpha = d3;
    }, c3 = (d3) => {
      n3.color.hue = d3;
    }, k2 = (d3) => {
      d3.hex !== void 0 && (n3.color.hex = d3.hex), d3.alpha !== void 0 && (n3.color.alpha = d3.alpha);
    }, p3 = (d3, m3) => {
      n3.color.saturation = d3, n3.color.brightness = m3;
    }, g3 = (d3) => {
      d3 !== "advance" && (n3.color.hex = d3);
    };
    return whenever(
      () => e2.color,
      (d3) => {
        d3 && (n3.color = d3);
      },
      { deep: true }
    ), whenever(
      () => n3.color,
      () => {
        n3.hex = n3.color.hex, n3.rgb = n3.color.toRgbString(), a3(), t3("update:color", n3.color), t3("change", n3.color);
      },
      { deep: true }
    ), {
      state: n3,
      previewStyle: i3,
      historyColors: l3,
      onAlphaChange: r3,
      onHueChange: c3,
      onBoardChange: p3,
      onInputChange: k2,
      onCompactChange: g3
    };
  }
});
var no2 = { class: "vc-chrome-colorPicker" };
var ao2 = { class: "vc-chrome-colorPicker-body" };
var ro2 = { class: "chrome-controls" };
var lo2 = { class: "chrome-sliders" };
function so2(e2, t3, o3, n3, i3, l3) {
  const a3 = resolveComponent("Board"), r3 = resolveComponent("Hue"), c3 = resolveComponent("Alpha"), k2 = resolveComponent("Display"), p3 = resolveComponent("History");
  return openBlock(), createElementBlock("div", no2, [
    createVNode(a3, {
      round: true,
      hide: false,
      color: e2.state.color,
      onChange: e2.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createBaseVNode("div", ao2, [
      createBaseVNode("div", ro2, [
        createBaseVNode("div", lo2, [
          createVNode(r3, {
            size: "small",
            color: e2.state.color,
            onChange: e2.onHueChange
          }, null, 8, ["color", "onChange"]),
          e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(c3, {
            key: 0,
            size: "small",
            color: e2.state.color,
            onChange: e2.onAlphaChange
          }, null, 8, ["color", "onChange"]))
        ])
      ]),
      createVNode(k2, {
        color: e2.state.color,
        "disable-alpha": e2.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(p3, {
        key: 0,
        round: e2.roundHistory,
        colors: e2.historyColors,
        onChange: e2.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
var Ve2 = q2(oo2, [["render", so2], ["__scopeId", "data-v-2611d66c"]]);
var ke2 = "Vue3ColorPickerProvider";
var io2 = (e2, t3) => {
  const o3 = e2.getBoundingClientRect(), n3 = o3.left + o3.width / 2, i3 = o3.top + o3.height / 2, l3 = Math.abs(n3 - t3.clientX), a3 = Math.abs(i3 - t3.clientY), r3 = Math.sqrt(Math.pow(l3, 2) + Math.pow(a3, 2)), c3 = a3 / r3, k2 = Math.acos(c3);
  let p3 = Math.floor(180 / (Math.PI / k2));
  return t3.clientX > n3 && t3.clientY > i3 && (p3 = 180 - p3), t3.clientX == n3 && t3.clientY > i3 && (p3 = 180), t3.clientX > n3 && t3.clientY == i3 && (p3 = 90), t3.clientX < n3 && t3.clientY > i3 && (p3 = 180 + p3), t3.clientX < n3 && t3.clientY == i3 && (p3 = 270), t3.clientX < n3 && t3.clientY < i3 && (p3 = 360 - p3), p3;
};
var de2 = false;
var co2 = (e2, t3) => {
  const o3 = function(i3) {
    var l3;
    (l3 = t3.drag) == null || l3.call(t3, i3);
  }, n3 = function(i3) {
    var l3;
    document.removeEventListener("mousemove", o3, false), document.removeEventListener("mouseup", n3, false), document.onselectstart = null, document.ondragstart = null, de2 = false, (l3 = t3.end) == null || l3.call(t3, i3);
  };
  e2 && e2.addEventListener("mousedown", (i3) => {
    var l3;
    de2 || (document.onselectstart = () => false, document.ondragstart = () => false, document.addEventListener("mousemove", o3, false), document.addEventListener("mouseup", n3, false), de2 = true, (l3 = t3.start) == null || l3.call(t3, i3));
  });
};
var uo2 = {
  angle: {
    type: Number,
    default: 0
  },
  size: {
    type: Number,
    default: 16,
    validator: (e2) => e2 >= 16
  },
  borderWidth: {
    type: Number,
    default: 1,
    validator: (e2) => e2 >= 1
  },
  borderColor: {
    type: String,
    default: "#666"
  }
};
var go2 = defineComponent({
  name: "Angle",
  props: uo2,
  emits: ["update:angle", "change"],
  setup(e2, {
    emit: t3
  }) {
    const o3 = ref(null), n3 = ref(0);
    watch(() => e2.angle, (r3) => {
      n3.value = r3;
    });
    const i3 = () => {
      let r3 = Number(n3.value);
      isNaN(r3) || (r3 = r3 > 360 || r3 < 0 ? e2.angle : r3, n3.value = r3 === 360 ? 0 : r3, t3("update:angle", n3.value), t3("change", n3.value));
    }, l3 = computed(() => ({
      width: e2.size + "px",
      height: e2.size + "px",
      borderWidth: e2.borderWidth + "px",
      borderColor: e2.borderColor,
      transform: `rotate(${n3.value}deg)`
    })), a3 = (r3) => {
      o3.value && (n3.value = io2(o3.value, r3) % 360, i3());
    };
    return onMounted(() => {
      const r3 = {
        drag: (c3) => {
          a3(c3);
        },
        end: (c3) => {
          a3(c3);
        }
      };
      o3.value && co2(o3.value, r3);
    }), () => createVNode("div", {
      class: "bee-angle"
    }, [createVNode("div", {
      class: "bee-angle__round",
      ref: o3,
      style: l3.value
    }, null)]);
  }
});
var ho2 = defineComponent({
  name: "GradientColorPicker",
  components: { Angle: go2, Display: Se2, Alpha: ve2, Palette: Ke2, Board: ye2, Hue: _e2, Lightness: Le2, History: me2 },
  props: {
    startColor: C.instanceOf(A3).isRequired,
    endColor: C.instanceOf(A3).isRequired,
    startColorStop: C.number.def(0),
    endColorStop: C.number.def(100),
    angle: C.number.def(0),
    type: C.oneOf(["linear", "radial"]).def("linear"),
    disableHistory: C.bool.def(false),
    roundHistory: C.bool.def(false),
    disableAlpha: C.bool.def(false),
    pickerType: C.oneOf(["fk", "chrome"]).def("fk")
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange",
    "typeChange"
  ],
  setup(e2, { emit: t3 }) {
    const o3 = reactive({
      startActive: true,
      startColor: e2.startColor,
      endColor: e2.endColor,
      startColorStop: e2.startColorStop,
      endColorStop: e2.endColorStop,
      angle: e2.angle,
      type: e2.type,
      // rgba
      startColorRgba: e2.startColor.toRgbString(),
      endColorRgba: e2.endColor.toRgbString()
    }), n3 = inject(ke2), i3 = ref(e2.pickerType === "chrome"), l3 = ref(), a3 = ref(), r3 = ref();
    watch(
      () => [e2.startColor, e2.endColor, e2.angle],
      (s3) => {
        o3.startColor = s3[0], o3.endColor = s3[1], o3.angle = s3[2];
      }
    ), watch(
      () => e2.type,
      (s3) => {
        o3.type = s3;
      }
    );
    const c3 = computed({
      get: () => o3.startActive ? o3.startColor : o3.endColor,
      set: (s3) => {
        if (o3.startActive) {
          o3.startColor = s3;
          return;
        }
        o3.endColor = s3;
      }
    }), k2 = computed(() => {
      if (r3.value && l3.value) {
        const s3 = o3.startColorStop / 100, _3 = r3.value.getBoundingClientRect(), H2 = l3.value.offsetWidth;
        return Math.round(s3 * (_3.width - H2) + H2 / 2);
      }
      return 0;
    }), p3 = computed(() => {
      if (r3.value && a3.value) {
        const s3 = o3.endColorStop / 100, _3 = r3.value.getBoundingClientRect(), H2 = a3.value.offsetWidth;
        return Math.round(s3 * (_3.width - H2) + H2 / 2);
      }
      return 0;
    }), g3 = computed(() => {
      let s3 = `background: linear-gradient(${o3.angle}deg, ${o3.startColorRgba} ${o3.startColorStop}%, ${o3.endColorRgba} ${o3.endColorStop}%)`;
      return o3.type === "radial" && (s3 = `background: radial-gradient(circle, ${o3.startColorRgba} ${o3.startColorStop}%, ${o3.endColorRgba} ${o3.endColorStop}%)`), s3;
    }), d3 = (s3) => {
      var _3;
      if (o3.startActive = true, r3.value && l3.value) {
        const H2 = (_3 = r3.value) == null ? void 0 : _3.getBoundingClientRect();
        let N3 = s3.clientX - H2.left;
        N3 = Math.max(l3.value.offsetWidth / 2, N3), N3 = Math.min(N3, H2.width - l3.value.offsetWidth / 2), o3.startColorStop = Math.round(
          (N3 - l3.value.offsetWidth / 2) / (H2.width - l3.value.offsetWidth) * 100
        ), t3("update:startColorStop", o3.startColorStop), t3("startColorStopChange", o3.startColorStop);
      }
    }, m3 = (s3) => {
      var _3;
      if (o3.startActive = false, r3.value && a3.value) {
        const H2 = (_3 = r3.value) == null ? void 0 : _3.getBoundingClientRect();
        let N3 = s3.clientX - H2.left;
        N3 = Math.max(a3.value.offsetWidth / 2, N3), N3 = Math.min(N3, H2.width - a3.value.offsetWidth / 2), o3.endColorStop = Math.round(
          (N3 - a3.value.offsetWidth / 2) / (H2.width - a3.value.offsetWidth) * 100
        ), t3("update:endColorStop", o3.endColorStop), t3("endColorStopChange", o3.endColorStop);
      }
    }, b3 = (s3) => {
      const _3 = s3.target, H2 = parseInt(_3.value.replace("°", ""));
      isNaN(H2) || (o3.angle = H2 % 360), t3("update:angle", o3.angle), t3("angleChange", o3.angle);
    }, h4 = (s3) => {
      o3.angle = s3, t3("update:angle", o3.angle), t3("angleChange", o3.angle);
    }, y3 = (s3) => {
      s3 === "advance" ? (i3.value = true, t3("advanceChange", true)) : (c3.value.hex = s3, t3("advanceChange", false)), L3();
    }, f3 = (s3) => {
      c3.value.alpha = s3, L3();
    }, w3 = (s3) => {
      c3.value.hue = s3, L3();
    }, S3 = (s3, _3) => {
      c3.value.saturation = s3, c3.value.brightness = _3, L3();
    }, F3 = (s3) => {
      c3.value.lightness = s3, L3();
    }, E3 = () => {
      L3();
    }, L3 = () => {
      o3.startActive ? (t3("update:startColor", o3.startColor), t3("startColorChange", o3.startColor)) : (t3("update:endColor", o3.endColor), t3("endColorChange", o3.endColor));
    }, U2 = () => {
      i3.value = false, t3("advanceChange", false);
    }, J3 = () => {
      o3.type = o3.type === "linear" ? "radial" : "linear", t3("typeChange", o3.type);
    }, X = useLocalStorage(fe2, [], {}), ce2 = useDebounceFn(() => {
      if (e2.disableHistory)
        return;
      const s3 = c3.value.toRgbString();
      if (X.value = X.value.filter((_3) => !tinycolor.equals(_3, s3)), !X.value.includes(s3)) {
        for (; X.value.length > Ce2; )
          X.value.pop();
        X.value.unshift(s3);
      }
    }, 500);
    return tryOnMounted(() => {
      a3.value && l3.value && (Vn.triggerDragEvent(a3.value, {
        drag: (s3) => {
          m3(s3);
        },
        end: (s3) => {
          m3(s3);
        }
      }), Vn.triggerDragEvent(l3.value, {
        drag: (s3) => {
          d3(s3);
        },
        end: (s3) => {
          d3(s3);
        }
      }));
    }), whenever(
      () => o3.startColor,
      (s3) => {
        o3.startColorRgba = s3.toRgbString();
      },
      { deep: true }
    ), whenever(
      () => o3.endColor,
      (s3) => {
        o3.endColorRgba = s3.toRgbString();
      },
      { deep: true }
    ), whenever(
      () => c3.value,
      () => {
        ce2();
      },
      { deep: true }
    ), {
      startGradientRef: l3,
      stopGradientRef: a3,
      colorRangeRef: r3,
      state: o3,
      currentColor: c3,
      getStartColorLeft: k2,
      getEndColorLeft: p3,
      gradientBg: g3,
      advancePanelShow: i3,
      onDegreeBlur: b3,
      onCompactChange: y3,
      onAlphaChange: f3,
      onHueChange: w3,
      onBoardChange: S3,
      onLightChange: F3,
      historyColors: X,
      onBack: U2,
      onDegreeChange: h4,
      onDisplayChange: E3,
      onTypeChange: J3,
      lang: n3 == null ? void 0 : n3.lang
    };
  }
});
var Ne2 = (e2) => (pushScopeId("data-v-c4d6d6ea"), e2 = e2(), popScopeId(), e2);
var po2 = { class: "vc-gradient-picker" };
var fo2 = { class: "vc-gradient-picker__header" };
var Co2 = { class: "vc-gradient__types" };
var vo2 = { class: "vc-gradient-wrap__types" };
var bo2 = { class: "vc-picker-degree-input vc-degree-input" };
var yo2 = { class: "vc-degree-input__control" };
var _o2 = ["value"];
var mo2 = { class: "vc-degree-input__panel" };
var So2 = { class: "vc-degree-input__disk" };
var ko2 = { class: "vc-gradient-picker__body" };
var $o = {
  class: "vc-color-range",
  ref: "colorRangeRef"
};
var wo2 = { class: "vc-color-range__container" };
var Bo = { class: "vc-gradient__stop__container" };
var Ho = ["title"];
var Ro2 = Ne2(() => createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
var Ao2 = [
  Ro2
];
var Po2 = ["title"];
var Vo2 = Ne2(() => createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
var Mo2 = [
  Vo2
];
function Eo2(e2, t3, o3, n3, i3, l3) {
  var b3, h4;
  const a3 = resolveComponent("Angle"), r3 = resolveComponent("Board"), c3 = resolveComponent("Hue"), k2 = resolveComponent("Palette"), p3 = resolveComponent("Lightness"), g3 = resolveComponent("Alpha"), d3 = resolveComponent("Display"), m3 = resolveComponent("History");
  return openBlock(), createElementBlock("div", po2, [
    createBaseVNode("div", fo2, [
      createBaseVNode("div", null, [
        withDirectives(createBaseVNode("div", {
          class: "back",
          style: { cursor: "pointer" },
          onClick: t3[0] || (t3[0] = (...y3) => e2.onBack && e2.onBack(...y3))
        }, null, 512), [
          [vShow, e2.pickerType === "fk" && e2.advancePanelShow]
        ])
      ]),
      createBaseVNode("div", Co2, [
        createBaseVNode("div", vo2, [
          (openBlock(), createElementBlock(Fragment, null, renderList(["linear", "radial"], (y3) => createBaseVNode("div", {
            class: normalizeClass(["vc-gradient__type", { active: e2.state.type === y3 }]),
            key: y3,
            onClick: t3[1] || (t3[1] = (...f3) => e2.onTypeChange && e2.onTypeChange(...f3))
          }, toDisplayString(e2.lang ? e2.lang[y3] : y3), 3)), 64))
        ]),
        withDirectives(createBaseVNode("div", bo2, [
          createBaseVNode("div", yo2, [
            createBaseVNode("input", {
              value: e2.state.angle,
              onBlur: t3[2] || (t3[2] = (...y3) => e2.onDegreeBlur && e2.onDegreeBlur(...y3))
            }, null, 40, _o2),
            createTextVNode("deg ")
          ]),
          createBaseVNode("div", mo2, [
            createBaseVNode("div", So2, [
              createVNode(a3, {
                angle: e2.state.angle,
                "onUpdate:angle": t3[3] || (t3[3] = (y3) => e2.state.angle = y3),
                size: 40,
                onChange: e2.onDegreeChange
              }, null, 8, ["angle", "onChange"])
            ])
          ])
        ], 512), [
          [vShow, e2.state.type === "linear"]
        ])
      ])
    ]),
    createBaseVNode("div", ko2, [
      createBaseVNode("div", $o, [
        createBaseVNode("div", wo2, [
          createBaseVNode("div", {
            class: "vc-background",
            style: normalizeStyle(e2.gradientBg)
          }, null, 4),
          createBaseVNode("div", Bo, [
            createBaseVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": e2.state.startActive
              }]),
              ref: "startGradientRef",
              title: (b3 = e2.lang) == null ? void 0 : b3.start,
              style: normalizeStyle({ left: e2.getStartColorLeft + "px", backgroundColor: e2.state.startColorRgba })
            }, Ao2, 14, Ho),
            createBaseVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": !e2.state.startActive
              }]),
              ref: "stopGradientRef",
              title: (h4 = e2.lang) == null ? void 0 : h4.end,
              style: normalizeStyle({ left: e2.getEndColorLeft + "px", backgroundColor: e2.state.endColorRgba })
            }, Mo2, 14, Po2)
          ])
        ])
      ], 512)
    ]),
    e2.advancePanelShow ? (openBlock(), createBlock(r3, {
      key: 0,
      color: e2.currentColor,
      onChange: e2.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    e2.advancePanelShow ? (openBlock(), createBlock(c3, {
      key: 1,
      color: e2.currentColor,
      onChange: e2.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(k2, {
      key: 2,
      onChange: e2.onCompactChange
    }, null, 8, ["onChange"])),
    e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(p3, {
      key: 3,
      color: e2.currentColor,
      onChange: e2.onLightChange
    }, null, 8, ["color", "onChange"])),
    e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(g3, {
      key: 4,
      color: e2.currentColor,
      onChange: e2.onAlphaChange
    }, null, 8, ["color", "onChange"])),
    createVNode(d3, {
      color: e2.currentColor,
      "disable-alpha": e2.disableAlpha,
      onChange: e2.onDisplayChange
    }, null, 8, ["color", "disable-alpha", "onChange"]),
    e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(m3, {
      key: 5,
      round: e2.roundHistory,
      colors: e2.historyColors,
      onChange: e2.onCompactChange
    }, null, 8, ["round", "colors", "onChange"]))
  ]);
}
var Me2 = q2(ho2, [["render", Eo2], ["__scopeId", "data-v-c4d6d6ea"]]);
var Io2 = defineComponent({
  name: "WrapContainer",
  props: {
    theme: C.oneOf(["white", "black"]).def("white"),
    showTab: C.bool.def(false),
    activeKey: C.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(e2, { emit: t3 }) {
    const o3 = reactive({
      activeKey: e2.activeKey
    }), n3 = inject(ke2), i3 = (l3) => {
      o3.activeKey = l3, t3("update:activeKey", l3), t3("change", l3);
    };
    return whenever(
      () => e2.activeKey,
      (l3) => {
        o3.activeKey = l3;
      }
    ), { state: o3, onActiveKeyChange: i3, lang: n3 == null ? void 0 : n3.lang };
  }
});
var Ko = { class: "vc-colorpicker--container" };
var Lo2 = {
  key: 0,
  class: "vc-colorpicker--tabs"
};
var No2 = { class: "vc-colorpicker--tabs__inner" };
var Wo = { class: "vc-btn__content" };
var Do2 = { class: "vc-btn__content" };
function To2(e2, t3, o3, n3, i3, l3) {
  var a3, r3;
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-colorpicker", e2.theme])
  }, [
    createBaseVNode("div", Ko, [
      e2.showTab ? (openBlock(), createElementBlock("div", Lo2, [
        createBaseVNode("div", No2, [
          createBaseVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": e2.state.activeKey === "pure"
              }
            ]),
            onClick: t3[0] || (t3[0] = (c3) => e2.onActiveKeyChange("pure"))
          }, [
            createBaseVNode("button", null, [
              createBaseVNode("div", Wo, toDisplayString((a3 = e2.lang) == null ? void 0 : a3.pure), 1)
            ])
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": e2.state.activeKey === "gradient"
              }
            ]),
            onClick: t3[1] || (t3[1] = (c3) => e2.onActiveKeyChange("gradient"))
          }, [
            createBaseVNode("button", null, [
              createBaseVNode("div", Do2, toDisplayString((r3 = e2.lang) == null ? void 0 : r3.gradient), 1)
            ])
          ], 2),
          createBaseVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle({
              width: "50%",
              left: `calc(${e2.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      renderSlot(e2.$slots, "default", {}, void 0, true)
    ])
  ], 2);
}
var Oo2 = q2(Io2, [["render", To2], ["__scopeId", "data-v-0492277d"]]);
var zo = {
  start: "Start",
  end: "End",
  pure: "Pure",
  gradient: "Gradient",
  linear: "linear",
  radial: "radial"
};
var Go2 = {
  start: "开始",
  end: "结束",
  pure: "纯色",
  gradient: "渐变",
  linear: "线性",
  radial: "径向"
};
var Fo2 = {
  En: zo,
  "ZH-cn": Go2
};
var Xo = {
  isWidget: C.bool.def(false),
  pickerType: C.oneOf(["fk", "chrome"]).def("fk"),
  shape: C.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: C.string.def(
    "linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 100%)"
  ),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: C.bool.def(false),
  disableHistory: C.bool.def(false),
  roundHistory: C.bool.def(false),
  useType: C.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: C.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: C.number.def(9999),
  pickerContainer: {
    type: [String, HTMLElement],
    default: "body"
  },
  debounce: C.number.def(100),
  theme: C.oneOf(["white", "black"]).def("white"),
  blurClose: C.bool.def(false),
  defaultPopup: C.bool.def(false)
};
var qo = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker: Pe2, ChromeColorPicker: Ve2, GradientColorPicker: Me2, WrapContainer: Oo2 },
  inheritAttrs: false,
  props: Xo,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(e2, { emit: t3 }) {
    provide(ke2, {
      lang: computed(() => Fo2[e2.lang || "ZH-cn"])
    });
    const o3 = !!useSlots().extra, n3 = reactive({
      pureColor: e2.pureColor || "",
      activeKey: e2.useType === "gradient" ? "gradient" : e2.activeKey,
      //  "pure" | "gradient"
      isAdvanceMode: false
    }), i3 = new A3("#000"), l3 = new A3("#000"), a3 = new A3(n3.pureColor), r3 = reactive({
      startColor: i3,
      endColor: l3,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      type: "linear",
      gradientColor: e2.gradientColor
    }), c3 = ref(a3), k2 = ref(e2.defaultPopup), p3 = ref(null), g3 = ref(null);
    let d3 = null;
    const m3 = computed(() => ({
      background: n3.activeKey !== "gradient" ? tinycolor(n3.pureColor).toRgbString() : r3.gradientColor
    })), b3 = computed(() => n3.activeKey === "gradient" ? Me2.name : e2.pickerType === "fk" ? Pe2.name : Ve2.name), h4 = (s3) => {
      n3.isAdvanceMode = s3;
    }, y3 = computed(() => {
      const s3 = {
        disableAlpha: e2.disableAlpha,
        disableHistory: e2.disableHistory,
        roundHistory: e2.roundHistory,
        pickerType: e2.pickerType
      };
      return n3.activeKey === "gradient" ? {
        ...s3,
        startColor: r3.startColor,
        endColor: r3.endColor,
        angle: r3.angle,
        type: r3.type,
        startColorStop: r3.startColorStop,
        endColorStop: r3.endColorStop,
        onStartColorChange: (_3) => {
          r3.startColor = _3, E3();
        },
        onEndColorChange: (_3) => {
          r3.endColor = _3, E3();
        },
        onStartColorStopChange: (_3) => {
          r3.startColorStop = _3, E3();
        },
        onEndColorStopChange: (_3) => {
          r3.endColorStop = _3, E3();
        },
        onAngleChange: (_3) => {
          r3.angle = _3, E3();
        },
        onTypeChange: (_3) => {
          r3.type = _3, E3();
        },
        onAdvanceChange: h4
      } : {
        ...s3,
        disableAlpha: e2.disableAlpha,
        disableHistory: e2.disableHistory,
        roundHistory: e2.roundHistory,
        color: c3.value,
        onChange: J3,
        onAdvanceChange: h4
      };
    }), f3 = () => {
      k2.value = true, d3 ? d3.update() : U2();
    }, w3 = () => {
      k2.value = false;
    }, S3 = useDebounceFn(() => {
      !e2.isWidget && e2.blurClose && w3();
    }, 100);
    onClickOutside(g3, () => {
      w3();
    });
    const F3 = () => {
      var s3, _3, H2, N3;
      try {
        const [z3] = (0, import_gradient_parser.parse)(r3.gradientColor);
        if (z3 && z3.type.includes("gradient") && z3.colorStops.length >= 2) {
          const $e2 = z3.colorStops[0], we2 = z3.colorStops[1];
          r3.startColorStop = Number((s3 = $e2.length) == null ? void 0 : s3.value) || 0, r3.endColorStop = Number((_3 = we2.length) == null ? void 0 : _3.value) || 0, z3.type === "linear-gradient" && ((H2 = z3.orientation) == null ? void 0 : H2.type) === "angular" && (r3.angle = Number((N3 = z3.orientation) == null ? void 0 : N3.value) || 0), r3.type = z3.type.split("-")[0];
          const [We2, De2, Te2, Oe2] = $e2.value, [ze2, Ge2, Fe2, Xe2] = we2.value;
          r3.startColor = new A3({
            r: Number(We2),
            g: Number(De2),
            b: Number(Te2),
            a: Number(Oe2)
          }), r3.endColor = new A3({
            r: Number(ze2),
            g: Number(Ge2),
            b: Number(Fe2),
            a: Number(Xe2)
          });
        }
      } catch (z3) {
        console.log(`[Parse Color]: ${z3}`);
      }
    }, E3 = useDebounceFn(() => {
      const s3 = L3();
      try {
        r3.gradientColor = (0, import_gradient_parser.stringify)(s3), t3("update:gradientColor", r3.gradientColor), t3("gradientColorChange", r3.gradientColor);
      } catch (_3) {
        console.log(_3);
      }
    }, e2.debounce), L3 = () => {
      const s3 = [], _3 = r3.startColor.RGB.map((z3) => z3.toString()), H2 = r3.endColor.RGB.map((z3) => z3.toString()), N3 = [
        {
          type: "rgba",
          value: [_3[0], _3[1], _3[2], _3[3]],
          length: { value: r3.startColorStop + "", type: "%" }
        },
        {
          type: "rgba",
          value: [H2[0], H2[1], H2[2], H2[3]],
          length: { value: r3.endColorStop + "", type: "%" }
        }
      ];
      return r3.type === "linear" ? s3.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: r3.angle + "" },
        colorStops: N3
      }) : r3.type === "radial" && s3.push({
        type: "radial-gradient",
        orientation: [{ type: "shape", value: "circle" }],
        colorStops: N3
      }), s3;
    }, U2 = () => {
      p3.value && g3.value && (d3 = createPopper3(p3.value, g3.value, {
        placement: "auto",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          },
          {
            name: "flip",
            options: {
              allowedAutoPlacements: ["top", "bottom", "left", "right"],
              rootBoundary: "viewport"
            }
          }
        ]
      }));
    }, J3 = (s3) => {
      c3.value = s3, n3.pureColor = s3.toString(e2.format), X();
    }, X = useDebounceFn(() => {
      t3("update:pureColor", n3.pureColor), t3("pureColorChange", n3.pureColor);
    }, e2.debounce), ce2 = (s3) => {
      n3.activeKey = s3, t3("update:activeKey", s3), t3("activeKeyChange", s3);
    };
    return tryOnMounted(() => {
      F3(), d3 || U2();
    }), whenever(
      () => e2.gradientColor,
      (s3) => {
        s3 != r3.gradientColor && (r3.gradientColor = s3);
      }
    ), whenever(
      () => r3.gradientColor,
      () => {
        F3();
      }
    ), whenever(
      () => e2.activeKey,
      (s3) => {
        n3.activeKey = s3;
      }
    ), whenever(
      () => e2.useType,
      (s3) => {
        n3.activeKey !== "gradient" && s3 === "gradient" ? n3.activeKey = "gradient" : n3.activeKey = "pure";
      }
    ), whenever(
      () => e2.pureColor,
      (s3) => {
        tinycolor.equals(s3, n3.pureColor) || (n3.pureColor = s3, c3.value = new A3(s3));
      },
      { deep: true }
    ), {
      colorCubeRef: p3,
      pickerRef: g3,
      showPicker: k2,
      colorInstance: c3,
      getBgColorStyle: m3,
      getComponentName: b3,
      getBindArgs: y3,
      state: n3,
      hasExtra: o3,
      onColorChange: J3,
      onShowPicker: f3,
      onActiveKeyChange: ce2,
      onAutoClose: S3
    };
  }
});
var Yo2 = {
  key: 0,
  class: "vc-color-extra"
};
var Uo2 = {
  key: 0,
  class: "vc-color-extra"
};
function jo2(e2, t3, o3, n3, i3, l3) {
  const a3 = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    e2.isWidget ? (openBlock(), createBlock(a3, {
      key: 0,
      "active-key": e2.state.activeKey,
      "onUpdate:activeKey": t3[0] || (t3[0] = (r3) => e2.state.activeKey = r3),
      "show-tab": e2.useType === "both",
      style: normalizeStyle({ zIndex: e2.zIndex }),
      theme: e2.theme,
      onChange: e2.onActiveKeyChange
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16)),
        e2.hasExtra ? (openBlock(), createElementBlock("div", Yo2, [
          renderSlot(e2.$slots, "extra", {}, void 0, true)
        ])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["active-key", "show-tab", "style", "theme", "onChange"])) : createCommentVNode("", true),
    e2.isWidget ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-color-wrap transparent", { round: e2.shape === "circle" }]),
        ref: "colorCubeRef"
      }, [
        createBaseVNode("div", {
          class: "current-color",
          style: normalizeStyle(e2.getBgColorStyle),
          onClick: t3[1] || (t3[1] = (...r3) => e2.onShowPicker && e2.onShowPicker(...r3))
        }, null, 4)
      ], 2),
      (openBlock(), createBlock(Teleport, { to: e2.pickerContainer }, [
        withDirectives(createBaseVNode("div", {
          ref: "pickerRef",
          style: normalizeStyle({ zIndex: e2.zIndex }),
          onMouseleave: t3[3] || (t3[3] = (...r3) => e2.onAutoClose && e2.onAutoClose(...r3))
        }, [
          e2.showPicker ? (openBlock(), createBlock(a3, {
            key: 0,
            "show-tab": e2.useType === "both" && !e2.state.isAdvanceMode,
            theme: e2.theme,
            "active-key": e2.state.activeKey,
            "onUpdate:activeKey": t3[2] || (t3[2] = (r3) => e2.state.activeKey = r3),
            onChange: e2.onActiveKeyChange
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16)),
              e2.hasExtra ? (openBlock(), createElementBlock("div", Uo2, [
                renderSlot(e2.$slots, "extra", {}, void 0, true)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["show-tab", "theme", "active-key", "onChange"])) : createCommentVNode("", true)
        ], 36), [
          [vShow, e2.showPicker]
        ])
      ], 8, ["to"]))
    ], 64))
  ], 64);
}
var re2 = q2(qo, [["render", jo2], ["__scopeId", "data-v-354ca836"]]);
var rn2 = {
  install: (e2) => {
    e2.component(re2.name, re2), e2.component("Vue3" + re2.name, re2);
  }
};
export {
  re2 as ColorPicker,
  rn2 as default
};
/*! Bundled license information:

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=vue3-colorpicker.js.map
